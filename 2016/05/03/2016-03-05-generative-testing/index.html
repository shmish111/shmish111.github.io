<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Generative Testing · Hexo</title><meta name="description" content="Generative Testing - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Generative Testing</h1><div class="post-time">May 3, 2016</div><div class="post-content"><p>I have gone through various stages of learning about testing software and how it relates to producing great products so I’d like to write a small series of posts based around this experience, detailing what I’ve learnt along with some real world examples. In this first instalment I’m going to introduce generative and property based testing.</p>
<h2 id="Property-Based-Testing"><a href="#Property-Based-Testing" class="headerlink" title="Property Based Testing"></a>Property Based Testing</h2><p>Property based testing is a method of testing functions pioneered by the Haskell community. From Hackage:</p>
<blockquote>
<p>QuickCheck is a library for random testing of program properties.</p>
<p>The programmer provides a specification of the program, in the form of properties which functions should satisfy, and QuickCheck then tests that the properties hold in a large number of randomly generated cases.</p>
</blockquote>
<p>As a simple example lets say you have a function which will reverse a vector of integers. You provide a ‘generator’ which will generate vectors of random size containing random integer, you then use these as inputs into your functions. Finally you provide a set of properties that should hold true, in this example we can say that reversing a list twice should result in the original list. A library such as QuickCheck or Clojure’s <code>test.check</code> will then try to find an example that will cause the test to fail by generating hundreds or thousands of test cases.</p>
<p>This all sounds great however all the online examples are testing small, pure functions that are only a small part of the software we write. Impressive as it is, I was struggling to see how often I would use this type of testing in my everyday development of systems such as HTTP microservices, which often have limited functionality and not much complex logic. That all changed once I started to have go however.</p>
<h2 id="Generative-Testing"><a href="#Generative-Testing" class="headerlink" title="Generative Testing"></a>Generative Testing</h2><p>The first thing to note is that property based testing libraries have 2 distinct parts. The first is a clever test runner that will try to find the simplest failing case, the second is a framework for random value generation. It was these value generators that interested me the most as they can be used very effectively without the test runner.</p>
<p>I believe that one of the most valuable ways to test software is to test against the API of whatever you are developing, with an HTTP microservice this is the HTTP endpoints. I like to run up an instance of the microservice and consider that to be the unit that I am testing. It’s easy to write tests that send requests via HTTP and it’s usually easy to verify the results. When you write these tests, you will often have to write test data (aka fixtures), for example lets say we have a microservice for dealing with customer details. This is likely a CRUD service so we might write a test that POSTs a new customer and then tries to GET the customer. We will define some sample data to build a new customer request:</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a-customer</span><br><span class="line">  &#123;<span class="symbol">:name</span> <span class="string">"David Smith"</span></span><br><span class="line">   <span class="symbol">:age</span> <span class="number">21</span></span><br><span class="line">   <span class="symbol">:gender</span> <span class="string">"male"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>We can then re-use this in various different tests. We may even turn this into a function to try to vary the details for certain tests:</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> a-customer</span><br><span class="line">  [m]</span><br><span class="line">  (<span class="name"><span class="builtin-name">merge</span></span> &#123;<span class="symbol">:name</span>   <span class="string">"David Smith"</span></span><br><span class="line">          <span class="symbol">:age</span>    <span class="number">21</span></span><br><span class="line">          <span class="symbol">:gender</span> <span class="string">"male"</span>&#125;</span><br><span class="line">         m))</span><br></pre></td></tr></table></figure>
<p>An alternative would be to use generators to create our data:  </p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a-customer</span><br><span class="line">  (<span class="name">gen/hash-map</span> <span class="symbol">:name</span> gen/string</span><br><span class="line">                <span class="symbol">:age</span> gen/int</span><br><span class="line">                <span class="symbol">:gender</span> gen/string))</span><br><span class="line"></span><br><span class="line">(<span class="name">deftest</span> my-test</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [new-customer (<span class="name">gen/generate</span> a-customer)]))</span><br></pre></td></tr></table></figure>
<p>So why would you use the generated version? First it means you don’t have to waste your time coming up with witty values but more importantly you are more correctly defining how your function works. In production, the service will not receive a customer whose name is “David Smith”, it will receive a name whose value is a string. With a generator we state this explicitly. On top of that, generators tend to generate loads of rubbish that can screw with your functions surprisingly quickly; you often don’t need to run the tests hundreds of times before some special case breaks it, I’ve found quite a few bugs the first time I hit the service with generated data.</p>
<p>Generators can be a bit daunting at first, I thought that it may become so complicated that you would need to test your generators! It turns out though that this is not the case and property testing libraries have the tools to generate just about anything fairly easily. You can also come up with your own patterns and helpers to make things easier. One of the best examples of this is Prismatic Schema’s experimental generators. Given any schema, the library will provide you with a generator to generate values that conform to this schema. If you are already validating your new customer in the microservice using schema then there is really no work involved:</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">sg/generate</span> Customer)</span><br></pre></td></tr></table></figure>
<p>It really is as simple as that, we’ve eliminated the tedious work of writing sample data and at the same time we’ve increased the scope for finding bugs.</p>
<h2 id="Where-next"><a href="#Where-next" class="headerlink" title="Where next"></a>Where next</h2><p>Generators provide some value in creating standard, single, unit and integration tests but they’re not adding that much. Why go to the effort then? In the next instalment we will see how they were crucial in finding hidden bugs in a real-life application.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/08/2016-05-04-load-testing/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">John Doe</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>