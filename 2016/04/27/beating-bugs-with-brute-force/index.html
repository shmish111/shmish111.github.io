<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Beating Bugs With Brute Force · Continuously Improving</title><meta name="description" content="Beating Bugs With Brute Force - David Smith"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/shmish111" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Beating Bugs With Brute Force</h1><div class="post-time">Apr 27, 2016</div><div class="post-content"><blockquote>
<p>Improve product quality and find bugs faster by generating tests.</p>
</blockquote>
<p>For years I’ve been writing the tests for the applications I write however it turns out that computers can do a better job. Property based testing is the doorway to a more advanced world of testing that can dramatically improve quality and find bugs that would have appeared on day 1 in prod.<br><a id="more"></a></p>
<h2 id="Generative-Testing"><a href="#Generative-Testing" class="headerlink" title="Generative Testing"></a>Generative Testing</h2><p>When you write tests, you will often have to write test data (aka fixtures), for example lets say we have a microservice for dealing with customer details. This is likely a CRUD service so we might write a test that POSTs a new customer and then tries to GET the customer. We will define some sample data to build a new customer request:</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a-customer</span><br><span class="line">  &#123;<span class="symbol">:name</span> <span class="string">"David Smith"</span></span><br><span class="line">   <span class="symbol">:age</span> <span class="number">21</span></span><br><span class="line">   <span class="symbol">:gender</span> <span class="string">"male"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>We can then re-use this in various different tests. We may even turn this into a function to try to vary the details for certain tests:</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> a-customer</span><br><span class="line">  [m]</span><br><span class="line">  (<span class="name"><span class="builtin-name">merge</span></span> &#123;<span class="symbol">:name</span>   <span class="string">"David Smith"</span></span><br><span class="line">          <span class="symbol">:age</span>    <span class="number">21</span></span><br><span class="line">          <span class="symbol">:gender</span> <span class="string">"male"</span>&#125;</span><br><span class="line">         m))</span><br></pre></td></tr></table></figure>
<p>An alternative would be to use generators to create our data:  </p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> a-customer</span><br><span class="line">  (<span class="name">gen/hash-map</span> <span class="symbol">:name</span> gen/string</span><br><span class="line">                <span class="symbol">:age</span> gen/int</span><br><span class="line">                <span class="symbol">:gender</span> gen/string))</span><br><span class="line"></span><br><span class="line">(<span class="name">deftest</span> my-test</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [new-customer (<span class="name">gen/generate</span> a-customer)]))</span><br></pre></td></tr></table></figure>
<p>The <code>gen</code> namespace is part of a Clojure library called <a href="https://github.com/clojure/test.check" target="_blank" rel="external">test.check</a> which provides functions for generating random data. For example, <code>gen/string</code> will generate a random string, <code>gen/int</code> will generate a random integer etc.</p>
<p>So why would you use the generated version? First it means you don’t have to waste your time coming up with witty values but more importantly you are more correctly defining how your function works. In production, the service will not always receive a customer whose name is “David Smith”, it will receive a name whose value is a string. With a generator we state this explicitly. On top of that, generators tend to generate loads of rubbish that can screw with your functions surprisingly quickly; I’ve found quite a few bugs the first time I hit the service with generated data.</p>
<p>Generators can be a bit daunting at first, I thought that they may become so complicated that you would need to test your generators! It turns out though that this is not the case and property testing libraries like test.check have the tools to generate just about anything fairly easily. You can also come up with your own patterns and helpers to make things easier. One of the best examples of this is Plumatic Schema’s experimental generators.</p>
<p>Given any schema, the library will provide you with a generator to generate values that conform to this schema. If you are already validating your new customer in the microservice using schema then there is really no work involved:</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defschema</span> Customer</span><br><span class="line">  &#123;<span class="symbol">:name</span> s/Str</span><br><span class="line">   <span class="symbol">:age</span> s/Int</span><br><span class="line">   <span class="symbol">:gender</span> s/Str&#125;)</span><br><span class="line"></span><br><span class="line">(<span class="name">sg/generate</span> Customer)</span><br></pre></td></tr></table></figure>
<p>It really is as simple as that, we’ve eliminated the tedious work of writing sample data and at the same time we’ve increased the scope for finding bugs.</p>
<h2 id="Property-Based-Testing"><a href="#Property-Based-Testing" class="headerlink" title="Property Based Testing"></a>Property Based Testing</h2><p>Property based testing is a method of testing functions pioneered by the Haskell community. From Hackage:</p>
<blockquote>
<p>QuickCheck is a library for random testing of program properties.</p>
<p>The programmer provides a specification of the program, in the form of properties which functions should satisfy, and QuickCheck then tests that the properties hold in a large number of randomly generated cases.</p>
</blockquote>
<p>Property based testing libraries such as test.check have 2 distinct parts. The first part is a framework for random value generation as we saw above, the second part is a clever test runner that will try to find the simplest failing case.</p>
<p>As a simple example taken directly from the test.check README.md, lets say you have a function called <code>sort</code> which will reverse a vector of integers. You provide a generator which will generate vectors of random sizes containing random integers, you then use these as inputs into your functions. Finally you provide a set of properties that should hold true, in this example we can say that reversing a list twice should result in the original list. A library such as QuickCheck or Clojure’s <code>test.check</code> will then try to find an example that will cause the test to fail by generating hundreds or thousands of test cases.</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> sort-idempotent-prop</span><br><span class="line">  (<span class="name">prop/for-all</span> [v (<span class="name">gen/vector</span> gen/int)]</span><br><span class="line">    (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">sort</span></span> v) (<span class="name"><span class="builtin-name">sort</span></span> (<span class="name"><span class="builtin-name">sort</span></span> v)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">tc/quick-check</span> <span class="number">100</span> sort-idempotent-prop)</span><br><span class="line"><span class="comment">;; =&gt; &#123;:result true, :num-tests 100, :seed 1382488326530&#125;</span></span><br></pre></td></tr></table></figure>
<p>This all sounds great however all the online examples are testing small, pure functions that are only a small part of the software we write. Impressive as it is, I was struggling to see how often I would use this type of testing in my everyday development of systems such as HTTP microservices, which often have limited functionality and not much complex logic. However that all changed once I started to have go!</p>
<h2 id="You-wanna-play-rough"><a href="#You-wanna-play-rough" class="headerlink" title="You wanna play rough?"></a>You wanna play rough?</h2><p>In a recent project we had built a microservice that would take a request through a RESTful interface, provide a small amount of validation and the place the result on RabbitMQ. For this microservice we had chosen the excellent Yada library to take care of all the HTTP/REST infrastructure for us.</p>
<p>The service wouldn’t be used in a particularly intensive way however the team felt that it would be a good idea to write some load tests to see at what point it falls down and what happens when it does.</p>
<h2 id="Say-hello-to-my-little-friend"><a href="#Say-hello-to-my-little-friend" class="headerlink" title="Say hello to my little friend!"></a>Say hello to my little friend!</h2><p>We decided to use clj-gatling for our load testing. This is a clojure testing tool which is designed primarily for hitting servers with thousands of requests in parallel and producing nice reports about what happened. Since we had already written integration tests to check the functionality of the service (using <code>test.check</code>), it was simply a matter of reusing these tests in a slightly modified manner. We would hit the service on a few of the endpoints and check that the appropriate messages were present on the Rabbit queue. I knew that both RabbitMQ and the aleph server that yada uses were designed for high performance so I imagined that we would have to really push things to see any problems, after all, we had already verified that the service worked reliably with the integration tests.</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">deftest</span> load-test-all-endpoints</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [&#123;<span class="symbol">:keys</span> [api-root test-config]&#125; (<span class="name">test-common/load-config</span>)]</span><br><span class="line">    (<span class="name">g/run-simulation</span> [&#123;<span class="symbol">:name</span>     <span class="string">"sequentially try each endpoint"</span></span><br><span class="line">                        <span class="symbol">:requests</span> [&#123;<span class="symbol">:name</span> <span class="string">"Put user on queue"</span></span><br><span class="line">                                    <span class="symbol">:fn</span>   (<span class="name"><span class="builtin-name">partial</span></span> post-user api-root)&#125;</span><br><span class="line">                                   &#123;<span class="symbol">:name</span> <span class="string">"Put articles queue"</span></span><br><span class="line">                                    <span class="symbol">:fn</span>   (<span class="name"><span class="builtin-name">partial</span></span> post-articles-csv api-root)&#125;</span><br><span class="line">                                   &#123;<span class="symbol">:name</span> <span class="string">"hit health check endoint"</span></span><br><span class="line">                                    <span class="symbol">:fn</span>   (<span class="name"><span class="builtin-name">partial</span></span> health-check api-root)&#125;]&#125;]</span><br><span class="line">                      (<span class="symbol">:users</span> test-config)</span><br><span class="line">                      &#123;<span class="symbol">:requests</span> (<span class="symbol">:requests</span> test-config)&#125;)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> [total-tests (<span class="name"><span class="builtin-name">+</span></span> @post-user-count @post-articles-csv-count)]</span><br><span class="line">      (<span class="name">is</span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> (<span class="name"><span class="builtin-name">count</span></span> @errors)) (<span class="name"><span class="builtin-name">format</span></span> <span class="string">"some requests failed e.g. %s"</span> (<span class="name"><span class="builtin-name">first</span></span> @errors)))</span><br><span class="line">      (<span class="name">eventually-is</span> (<span class="name"><span class="builtin-name">=</span></span> total-tests (<span class="name"><span class="builtin-name">count</span></span> (<span class="name"><span class="builtin-name">keys</span></span> (<span class="name"><span class="builtin-name">deref</span></span> test-common/msgs)))) (<span class="symbol">:message-timeout</span> test-config)</span><br><span class="line">                     (<span class="name"><span class="builtin-name">format</span></span> <span class="string">"all messages should be received within %sms"</span> (<span class="symbol">:message-timeout</span> test-config))))))</span><br></pre></td></tr></table></figure>
<h2 id="Who-put-this-thing-together"><a href="#Who-put-this-thing-together" class="headerlink" title="Who put this thing together?"></a>Who put this thing together?</h2><p>In the first run I decided to hit the service with 1000 requests from 10 ‘users’ in parallel. One of the endpoints was a CSV file upload and I was surprised to find that some of the messages from this endpoint had not appeared on the queue. My initial reaction was that perhaps there was a small overhead getting messages on to Rabbit and although throughput would be high, I might need to give a bit of time after the test had fired it’s requests to see all the results. However I discovered that the messages were simply not getting put on the Rabbit queue, they were just disappearing.</p>
<p>With some old-school ‘print line’ debugging, it was possible to see that request was getting in to the server but the body was not appearing in my yada handler. This would happen for about 0.5% - 1% of requests, which of course we would never have found with our integration tests. Perhaps occasionally we would have a failed Jenkins build but run it again and everything would pass, it would, in all probability, be put down to something weird on the Jenkins slave and be ignored. We would have lost data in production at some point.</p>
<h2 id="Lesson-number-one-Lesson-number-two"><a href="#Lesson-number-one-Lesson-number-two" class="headerlink" title="Lesson number one; Lesson number two"></a>Lesson number one; Lesson number two</h2><p>Firstly, this made us realise that we should give a 400 response if the body was empty, something we had failed to think about. Next, careful investigation revealed that the library yada was using for finding multipart boundaries was broken. As a side note, this library was a prime candidate for property based testing and it would have revealed this bug. Malcom, the author of yada promptly wrote his own implementation of the Boyer-Moore search algorithm to fix the issue. We ran the tests again but we saw the same failures! Working with Malcom we found that under certain circumstances, the logic of piecing together the chunks of an uploaded file was incorrect. The issue was fixed and finally the tests passed, we were able to push the service until we finally ran out of file descriptors.</p>
<h2 id="Now-you’re-talking-to-me-baby"><a href="#Now-you’re-talking-to-me-baby" class="headerlink" title="Now you’re talking to me baby!"></a>Now you’re talking to me baby!</h2><p>So what did I learn from this experience?</p>
<ol>
<li>Load tests are important, they can test more than just performance.</li>
<li>Generative tests are vital and can find bugs that would have resulted in loss of revenue.</li>
<li>Even wearing a QA hat, we can miss simple failure scenarios that should be planned for and dealt with appropriately (the 400 response in this case).</li>
<li>It’s vital to use libraries that are either battle tested or that are actively maintained so that bugs can be fixed promptly.</li>
<li>Property based testing should be applied where possible, especially when it comes to algorithm implementations such as the Boyer-Moore search.</li>
</ol>
</div></article></div></section><footer><div class="paginator"><a href="/2016/05/14/the-repl-as-a-business-tool/" class="prev">NEXT</a><a href="/2015/12/15/either-monad-or-exceptions/" class="next">PREVIOUS</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://shmish111.github.io">David Smith</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-52255315-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>