<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Every Day Recursion Schemes · Continuously Improving</title><meta name="description" content="Every Day Recursion Schemes - David Smith"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/shmish111" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Every Day Recursion Schemes</h1><div class="post-time">Apr 13, 2019</div><div class="post-content"><blockquote>
<p>Recursion schemes can have quite a steep learning curve but common patterns can be used without deep understanding.</p>
</blockquote>
<p>There is a lot of excellent literature out there explaining recursion schemes but it all starts off with the fundamentals and builds up from basic concepts. An alternative way of learning is to see a real-world example and once you are comfortable using it you can see where it comes from. In this post I want to present a simple pattern that I have started seeing quite often, I think it’s reasonably easy (and useful) to start using without really knowing what’s going on underneath.<br><a id="more"></a></p>
<h2 id="Spotting-Catamorphisms"><a href="#Spotting-Catamorphisms" class="headerlink" title="Spotting Catamorphisms"></a>Spotting Catamorphisms</h2><p>Recently I have been working on a DSL interpreter written in Purescript, this involves much manipulation of simple but recursive data types. In this situation there are some quick wins where recursion schemes can neaten up the code. Take a look at the following example which is loosely based on some real-world code that I was working on last week.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data Contract</span><br><span class="line">    = Null</span><br><span class="line">    | Pay Person Contract</span><br><span class="line">    | Redeem Person Contract</span><br><span class="line">    | Choice Boolean Contract Contract</span><br><span class="line"></span><br><span class="line">allPeople :: Contract -&gt; Set Person</span><br><span class="line">allPeople Null = Set.empty</span><br><span class="line">allPeople (Pay person contract) = Set.insert person (allPeople contract)</span><br><span class="line">allPeople (Redeem person contract) = Set.insert person (allPeople contract)</span><br><span class="line">allPeople (Choice _ c1 c2) = Set.union (allPeople c1) (allPeople c2)</span><br></pre></td></tr></table></figure>
<p>Here we have a DSL to represent some type of contract and one thing we want to do is extract a set of all people involved in a contract. This looks simple enough however things can get messy quickly as we add more constructors. Recursion schemes can help neaten things up with a catamorphism.</p>
<h2 id="Functorize-all-the-things"><a href="#Functorize-all-the-things" class="headerlink" title="Functorize all the things"></a>Functorize all the things</h2><p>First we need to functorize the data type:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data ContractF f</span><br><span class="line">    = NullF</span><br><span class="line">    | PayF Person f</span><br><span class="line">    | RedeemF Person f</span><br><span class="line">    | ChoiceF Boolean f f</span><br><span class="line"></span><br><span class="line">derive instance functorContract :: Functor ContractF</span><br></pre></td></tr></table></figure>
<p>We add a parameter <code>f</code> and we replace all points of recursion with <code>f</code>. Now, in order to make refactoring easier we create conversion functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Matryoshka.Class.Recursive (class Recursive)</span><br><span class="line">import Matryoshka.Class.Corecursive (class Corecursive)</span><br><span class="line"></span><br><span class="line">instance recursiveContract :: Recursive Contract ContractF where</span><br><span class="line">    project Null = NullF</span><br><span class="line">    project (Pay p c) = PayF p c</span><br><span class="line">    project (Redeem p c) = Redeem p c</span><br><span class="line">    project (Choice p c1 c2) = ChoiceF p c1 c2</span><br><span class="line"></span><br><span class="line">instance corecursiveContract :: Corecursive Contract ContractF where</span><br><span class="line">    embed NullF = Null</span><br><span class="line">    embed (PayF p c) = Pay p c</span><br><span class="line">    embed (RedeemF p c) = Redeem p c</span><br><span class="line">    embed (ChoiceF p c1 c2) = Choice p c1 c2</span><br></pre></td></tr></table></figure>
<p>These type classes are built in to the Purescript recursion schemes library <a href="https://pursuit.purescript.org/packages/purescript-matryoshka" target="_blank" rel="external">matryoshka</a>. This makes things a touch simpler later on as we don’t need to think about converting anything ourselves.</p>
<h2 id="Catamorphisms"><a href="#Catamorphisms" class="headerlink" title="Catamorphisms"></a>Catamorphisms</h2><p>With the boilerplate out of the way we are free to take our original pattern and convert it into a catamorphism:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- Notice that the type of `allPeople` remains unchanged</span><br><span class="line">-- matryoshka takes care of the conversion between Contract and ContractF for us</span><br><span class="line">allPeople :: Contract -&gt; Set Person</span><br><span class="line">allPeople = cata algebra</span><br><span class="line">    where</span><br><span class="line">        algebra :: Algebra ContractF (Set Person)</span><br><span class="line">        algebra NullF = Set.empty</span><br><span class="line">        algebra (PayF person s) = Set.insert person s</span><br><span class="line">        algebra (RedeemF person s) = Set.insert person s</span><br><span class="line">        algebra (ChoiceF _ s1 s2) = Set.union s1 s2</span><br></pre></td></tr></table></figure>
<p>The pattern here is that we take any point that was previously a recursive <code>(allPeople contract)</code> and remove the recursion, <code>cata</code> will take care of dealing with that for us. Now we can look at <code>algebra</code> and think about it without recursion, much simpler for the brain. Wherever we previously had a <code>Contract</code> we have already got a <code>Set Person</code>. In the type <code>ContractF f</code>, the <code>f</code> has magically become a <code>Set Person</code>.</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>This example is a bit contrived as we have massively increased the number of lines of code due to the boilerplate needed for the functorized version of <code>Contract</code>. In reality you start with <code>Recursive</code> and <code>Corecursive</code> instances to enable you to refactor existing code to use the functorized type however in the end you may end up using the functorized version everywhere at which time you can get rid of the original <code>Contract</code> data type and the <code>Recursive</code> and <code>Corecursive</code> instances and end up with zero boilerplate.</p>
<p>Additionally this example doesn’t show how much neater this small change can make things but when you have this pattern in many places and with data types that have lots of constructors, it can really make a big difference.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/09/23/freer-than-free/" class="next">PREVIOUS</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://shmish111.github.io">David Smith</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-52255315-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>