<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Continuously Improving</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/shmish111" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/18/safe-json-with-haskell/" class="post-title-link">Safe JSON with Haskell</a></h2><div class="post-time">Mar 18, 2017</div><div class="post-content"></div><a href="/2017/03/18/safe-json-with-haskell/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/14/the-repl-as-a-business-tool/" class="post-title-link">The REPL as a business tool</a></h2><div class="post-time">May 14, 2016</div><div class="post-content"><blockquote>
<p>The REPL can save hours of pain through pairing with non-technical colleagues.</p>
</blockquote>
<p>The boundary between a business user and a developer can often be a big source of waste. Going back and forth between the user and your code to discover what data is really needed can really cause pain and waste a huge amount of time. The REPL can be used as an interactive environment to pair with a user and write the exact code required, first time.<br></div><a href="/2016/05/14/the-repl-as-a-business-tool/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/27/beating-bugs-with-brute-force/" class="post-title-link">Beating Bugs With Brute Force</a></h2><div class="post-time">Apr 27, 2016</div><div class="post-content"><blockquote>
<p>Improve product quality and find bugs faster by generating tests.</p>
</blockquote>
<p>For years I’ve been writing the tests for the applications I write however it turns out that computers can do a better job. Property based testing is the doorway to a more advanced world of testing that can dramatically improve quality and find bugs that would have appeared on day 1 in prod.<br></div><a href="/2016/04/27/beating-bugs-with-brute-force/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/15/either-monad-or-exceptions/" class="post-title-link">Either monad or exceptions</a></h2><div class="post-time">Dec 15, 2015</div><div class="post-content"><blockquote>
<p>The <code>Either</code> monad from <a href="https://github.com/funcool/cats">cats</a> is pretty cool.</p>
</blockquote>
<p>Recently I was asked to complete a small test for a job interview in the form of a Clojure program. The idea of the program was to take commands from stdin and use them to mess around with a ‘canvas’, basically a super-primitive graphics program. It occured to me that since part of this would involve parsing and validating commands and displaying any errors, it might be a good opportunity to use the Either monad and see the current state of monad libraries in Clojure.<br></div><a href="/2015/12/15/either-monad-or-exceptions/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/09/09/static-vs-dynamic/" class="post-title-link">Static vs Dynamic</a></h2><div class="post-time">Sep 9, 2014</div><div class="post-content"><p>I have recently moved jobs and now I am using Clojure rather than Java and Scala. Before starting I had been reading up on the static vs dynamic typing argument. I enjoy all the type stuff, when you start learning Haskell and Scala there’s some really interesting things to learn and some parts of static typing can really help. Most notable for me is function signatures, I really find function signatures to be one of the best things about static typing.<br></div><a href="/2014/09/09/static-vs-dynamic/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/07/09/consistency-is-not-the-key/" class="post-title-link">Consistency is not the key</a></h2><div class="post-time">Jul 9, 2014</div><div class="post-content"><p>Everyone’s heard it, probably everyone’s said it and on the face of it it makes sense, “We need a consistent approach”, “Consistency will make our code more maintainable”, “Consistency will make it easier for new joiners to understand the code”. These days though, when it comes to software development, I’ve learnt to question everything and I’m questioning this attitude.<br></div><a href="/2014/07/09/consistency-is-not-the-key/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/07/07/coding-is-easy/" class="post-title-link">Coding is easy, software development is hard</a></h2><div class="post-time">Jul 7, 2014</div><div class="post-content"><p>Software developers like to write code. Well that makes sense but software development is the process of delivering working code to an environment where it provides value to a user. In my experience, a developer will generally spend their time doing the following tasks:</p>
<ul>
<li>Requirements Gathering</li>
<li>Writing code</li>
<li>Manual testing</li>
<li>Releasing</div><a href="/2014/07/07/coding-is-easy/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/06/24/the-trouble-with-scrum/" class="post-title-link">The Trouble With Scrum</a></h2><div class="post-time">Jun 24, 2014</div><div class="post-content"><p>In Scrum (and other time-boxed methods) a commitment is made at the start of the sprint to complete a certain amount of work.  This approach encourages on-time delivery of features, a team only commits to what it thinks it can do based on previous iterations and it makes sure this is delivered.  If things got a bit close towards the end then in the next sprint they should commit to a bit less and visa versa.  This seems like a noble and pragmatic approach at first however there are some flaws, mostly due to human nature.<br></div><a href="/2014/06/24/the-trouble-with-scrum/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/06/07/stupid-developers/" class="post-title-link">Stupid developers!</a></h2><div class="post-time">Jun 7, 2014</div><div class="post-content"><p>In my continuous quest to learn how to develop better software I’ve been reading a lot of articles warning us of the risks of ‘using Agile’. Often these articles or their comments have something along the lines of, “there are 3 types of developers, the bright ones, the normal ones and the stupid ones. The bright ones will make any methodology work and the stupid ones will make any methodology fail so we have to look out for ‘normal’ developers…”. Every time I read this it frustrates and annoys me so I thought I’d make my feelings public in the hope that someone will benefit from my opinion.<br></div><a href="/2014/06/07/stupid-developers/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/06/07/too-many-whens/" class="post-title-link">Too many Whens</a></h2><div class="post-time">Jun 7, 2014</div><div class="post-content"><p>I’ve put in quite a lot of effort learning about automated testing in the last few years and have become quite passionate (some may say opinionated) about the subject.  Through trial and error, reading and working with some experienced QAs, I’ve formed some rules for myself about how I write BDD style tests.  I’d like to share one of these as I can’t find anything on the internet that suggests or explains it.  The rule is:<br></div><a href="/2014/06/07/too-many-whens/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"></div><div class="copyright"><p>© 2015 - 2017 <a href="http://shmish111.github.io">David Smith</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-52255315-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>