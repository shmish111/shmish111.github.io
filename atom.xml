<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Continuously Improving</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shmish111.github.io/"/>
  <updated>2018-07-15T15:07:28.109Z</updated>
  <id>http://shmish111.github.io/</id>
  
  <author>
    <name>David Smith</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>To Batch Or Not To Batch</title>
    <link href="http://shmish111.github.io/2018/07/15/to-batch-or-not-to-batch/"/>
    <id>http://shmish111.github.io/2018/07/15/to-batch-or-not-to-batch/</id>
    <published>2018-07-14T23:00:00.000Z</published>
    <updated>2018-07-15T15:07:28.109Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Measure your test pipeline before trying to improve efficiency with batching&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In projects with lots of contributors and long running tests, it seems like common sense to batch features together in order to reduce the overhead of running the long tests. In this post I try to prove if this is a valid thing to do.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The code I used for this simulation is available &lt;a href=&quot;https://gitlab.com/shmish111/bisecting&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;on gitlab&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;The-Scenario&quot;&gt;&lt;a href=&quot;#The-Scenario&quot; class=&quot;headerlink&quot; title=&quot;The Scenario&quot;&gt;&lt;/a&gt;The Scenario&lt;/h2&gt;&lt;p&gt;Lets say we have 100 developers all contributing to a large and complex code base. In order to release a new version of the system, we have to carry out a load of tests and these tests include some end-to-end tests that are pretty slow. Lets say on average we get around 24 merge requests per day and a test run takes about an hour. In this situation it looks like we are only just going to make it, if the number of merge requests per day increases then we are going to end up with an ever increasing backlog. In order to increase the potential capacity we can batch together a few merge requests and test those. What happens if a test fails though? Well we can bisect the batch to find the merge request that caused the tests to fail and remove that one.&lt;/p&gt;
&lt;p&gt;This was in fact a real scenario in a previous contract of mine, in this case the time it took to merge a feature varied wildly since a bisection could take a few test runs to merge a batch, or it could take just 1 test run to merge. From previous jobs I had an intuition that in addition to leveling out the lead time, running each merge request in turn would actually be quicker on average. This turned out to be more or less correct however the amazing flakiness of the tests made it difficult for people to believe since the lead time was still very high. I wanted to prove that this should always be the case, not just from a small amount of anecdotal evidence.&lt;/p&gt;
&lt;h2 id=&quot;Method&quot;&gt;&lt;a href=&quot;#Method&quot; class=&quot;headerlink&quot; title=&quot;Method&quot;&gt;&lt;/a&gt;Method&lt;/h2&gt;&lt;p&gt;I’m sure that someone with the correct mathematical expertise could come up with a proof however since I don’t have this expertise I decided to simulate the scenario instead, this should be pretty simple with some Haskell!&lt;/p&gt;
&lt;h3 id=&quot;Test-cases&quot;&gt;&lt;a href=&quot;#Test-cases&quot; class=&quot;headerlink&quot; title=&quot;Test cases&quot;&gt;&lt;/a&gt;Test cases&lt;/h3&gt;&lt;p&gt;A merge request can be modeled as a boolean value, either it passes all tests or it doesn’t. In reality things aren’t quite this simple, merge requests can interact with each other in complex ways and test can be flaky and fail when the merge request is OK. However as a first approximation we will consider that all our tests are perfect, we will assume that our merge requests can interact though.&lt;/p&gt;
&lt;p&gt;We can then model a batch of merge requests as a list of booleans. One variable we have is how many merge requests are good and how many are bad. We can set a mean failure rate i.e. how likely is a merge request to fail? For simplicity I have used an integer for this, the percentage of merge requests that fail. We can then make a batch of merge requests by creating a list of 100 booleans where &lt;code&gt;n&lt;/code&gt; are &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;100 - n&lt;/code&gt; are &lt;code&gt;True&lt;/code&gt; and then shuffle them into a random order.&lt;/p&gt;
&lt;p&gt;A test run simply checks if any &lt;code&gt;False&lt;/code&gt; values exist in the batch.&lt;/p&gt;
&lt;h3 id=&quot;Bisection&quot;&gt;&lt;a href=&quot;#Bisection&quot; class=&quot;headerlink&quot; title=&quot;Bisection&quot;&gt;&lt;/a&gt;Bisection&lt;/h3&gt;&lt;p&gt;If there is a failing merge request in the batch then we can split the batch in 2 and check each sub-batch again. Unfortunately this isn’t a simple binary search since we may have multiple failing merge requests, we must therefor run tests against a sub-batch even if the opposing sub-batch failed. If a batch of 2 tests fails and one of those tests passes by itself, we can assume that the other test fails (in a scenario with flaky tests we cannot make this assumption). Consider an example:&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Failed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- left side&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Failed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--right side&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Passed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- left-left&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Passed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- left-right&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Don&#39;t&lt;/span&gt; need to check&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In this case we had to run the tests 4 times in order to merge all good requests, the same number of test runs as running all merge requests individually.&lt;/p&gt;
&lt;h2 id=&quot;Batch-Size&quot;&gt;&lt;a href=&quot;#Batch-Size&quot; class=&quot;headerlink&quot; title=&quot;Batch Size&quot;&gt;&lt;/a&gt;Batch Size&lt;/h2&gt;&lt;p&gt;Intuition told me that bigger batch sizes would perform worse, we can model the batch size by using &lt;code&gt;n = batchSize&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt;. We then need to scale the number of &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; values accordingly.&lt;/p&gt;
&lt;p&gt;As it turns out, my intuition was wrong, batch size has no effect other than to reduce the standard deviation, i.e. if we run a bigger batch size we get a more accurate value of the number of test runs required on average. This simplifies the code nicely.&lt;/p&gt;
&lt;h2 id=&quot;Results&quot;&gt;&lt;a href=&quot;#Results&quot; class=&quot;headerlink&quot; title=&quot;Results&quot;&gt;&lt;/a&gt;Results&lt;/h2&gt;&lt;p&gt;I used &lt;a href=&quot;http://hackage.haskell.org/package/Chart&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Chart&lt;/a&gt; to plot the results and increased the batch size to increase accuracy. I am able to produce a graph of test failure probability vs the number of test runs required on average. I added a line to the plot with a constant test runs value of the batch size, this represents the situation if we don’t batch at all.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/test-runs.svg&quot; alt=&quot;test runs&quot;&gt;&lt;/p&gt;
&lt;p&gt;We can see from this chart that if 24% or more merge requests fail then it is more efficient not to batch our merge requests.&lt;/p&gt;
&lt;p&gt;What about if our test runs are a bit flaky and they do fail occasionally when they should pass? One way to retry quite efficiently is to run tests against tests that we assume are bad because they failed when run with a test that passes by itself. We can simulate this in the following way:&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Failed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- run the left side&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Passed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- we could assume that the right side will fail however the original batch could have failed due to a flaky test, we will therefor run it anyway&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Failed&lt;/span&gt; or &lt;span class=&quot;type&quot;&gt;Passed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;If we make that addition to the algorithm we get the following results:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/flaky-test-runs.svg&quot; alt=&quot;flaky test runs&quot;&gt;&lt;/p&gt;
&lt;p&gt;We can see that now if 16% or more merge requests fail then it is more efficient not to batch our merge requests.&lt;/p&gt;
&lt;h2 id=&quot;Conclusions&quot;&gt;&lt;a href=&quot;#Conclusions&quot; class=&quot;headerlink&quot; title=&quot;Conclusions&quot;&gt;&lt;/a&gt;Conclusions&lt;/h2&gt;&lt;p&gt;So how does all this help us? Well, if your merge requests tend to pass more than 24% of the time then you can gain some speed by batching. If your tests are a bit flaky but more than 16% of merge requests still pass on average then you can use the alternative bisection algorithm and make some gains. Either way, if you are considering batching, it would be worthwhile recording the number of failed test runs without batching for a while and see how often merge requests fail.&lt;/p&gt;
&lt;p&gt;Of course this is just a simulation and there are other factors which affect reality. Its also worth noting that this simulation assumes that no heuristics or intelligence is used to pick out which tests are likely to be causing the failures. Think of the scenario where you use a &lt;code&gt;staging&lt;/code&gt; branch and carry out tests there before merging to master. In this scenario it is common for developers to inspect the test results and intelligently decide which merge requests to remove, thus increasing the chances of &lt;code&gt;staging&lt;/code&gt; passing next time without having to bisect. Experience has shown me that the ability to pick out bad merge requests tends to degrade as the number of merge requests in staging increases since the interaction between merge requests rapidly becomes more complex.&lt;/p&gt;
&lt;p&gt;We can say that whether batching is worth it or not depends only on the failure rate of merge requests and the algorithm (whether intelligent or not) used to find failing tests, it doesn’t matter how long your tests take. In the case of a simple bisection algorithm we can also say that it doesn’t matter what the batch size is either.&lt;/p&gt;
&lt;p&gt;There are other reasons why you may wish to avoid batching such as reducing the risk involved in releases by deploying smaller changes. Additionally we can say that improving code quality and code reviews can allow methods of increasing efficiency such as batching. Having multiple ‘tiers’ of testing could also make batching worth it since you could decrease the likelihood of failing merge requests in a batch as other, faster tests have already passed for those merge requests.&lt;/p&gt;
&lt;p&gt;The most important thing I will take away from this though is that if I am in a situation where batching is being considered (or removing existing batching) then I will make sure I spend some time measuring failure rates first before spending any engineering effort on building the test pipeline.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Measure your test pipeline before trying to improve efficiency with batching&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In projects with lots of contributors and long running tests, it seems like common sense to batch features together in order to reduce the overhead of running the long tests. In this post I try to prove if this is a valid thing to do.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Safe JSON with Haskell</title>
    <link href="http://shmish111.github.io/2017/03/18/safe-json-with-haskell/"/>
    <id>http://shmish111.github.io/2017/03/18/safe-json-with-haskell/</id>
    <published>2017-03-18T00:00:00.000Z</published>
    <updated>2017-03-18T16:40:05.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Haskell Generics + Aeson + QuickCheck For The Win&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recently I’ve been working on an HTTP API written in Haskell. One of the things that tends to be much easier and nicer in dynamic languages is dealing with JSON in these APIs, statically typed languages tend to have lots of boilerplate. Not only is this boilerplate annoying to write but it can cause small changes to the API into a big task.&lt;/p&gt;
&lt;p&gt;With Haskell (actually GHC) this is not the case.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;A great GHC extension is &lt;a href=&quot;https://ocharles.org.uk/blog/posts/2014-12-16-derive-generic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DeriveGeneric&lt;/a&gt; which can be used to define how to generate type class instances. &lt;a href=&quot;https://hackage.haskell.org/package/aeson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Aeson&lt;/a&gt; has made great use of this, lets look at the following example:&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;#123;-# LANGUAGE DeriveGeneric #-&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; Lib &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; GHC.Generics&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Data.Aeson&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Data.Text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;title&quot;&gt;name&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    , &lt;span class=&quot;title&quot;&gt;age&lt;/span&gt;  :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Eq&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Generic&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;ToJSON&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FromJSON&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Here we’ve defined a new record type &lt;code&gt;Person&lt;/code&gt; with 2 fields. You can imagine how this would look in JSON:&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;span class=&quot;attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;David&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;, &lt;span class=&quot;attr&quot;&gt;&quot;age&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The &lt;code&gt;instance ToJSON Person&lt;/code&gt; automatically creates an instance that will allow the &lt;code&gt;encode&lt;/code&gt; function to generate exactly the JSON above. In a similar way, &lt;code&gt;instance FromJSON Person&lt;/code&gt; will allow us to &lt;code&gt;decode&lt;/code&gt; the above JSON into a Person record. That’s 2 lines of code!&lt;/p&gt;
&lt;p&gt;Sometimes we might want to modify the JSON produced slightly, for example in order to generate lenses with TemplateHaskell you add an &lt;code&gt;_&lt;/code&gt; in front of the field names:&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;#123;-# LANGUAGE DeriveGeneric   #-&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;#123;-# LANGUAGE TemplateHaskell #-&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; Lib &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Control.Lens&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Data.Aeson&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Data.Aeson.Types&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Data.Text        (&lt;span class=&quot;type&quot;&gt;Text&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           GHC.Generics&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; _name :: &lt;span class=&quot;type&quot;&gt;Text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  , _age  :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Eq&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Generic&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;makeLenses&lt;/span&gt; &#39;&#39;&lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;ToJSON&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  toJSON = genericToJSON defaultOptions &amp;#123;fieldLabelModifier = drop &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FromJSON&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  parseJSON = genericParseJSON defaultOptions &amp;#123;fieldLabelModifier = drop &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;That’s not too bad, however now our JSON is a little less trustworthy, especially if we start doing even more customisation of the &lt;code&gt;ToJSON&lt;/code&gt; and &lt;code&gt;FromJSON&lt;/code&gt; instances. How do we know that the encode/decode functions work correctly?&lt;/p&gt;
&lt;p&gt;This is where QuickCheck comes in. Using &lt;a href=&quot;https://hackage.haskell.org/package/generic-arbitrary&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;generic-arbitrary&lt;/a&gt; we can create an &lt;code&gt;Arbitrary&lt;/code&gt; instance of &lt;code&gt;Person&lt;/code&gt; and use QuickCheck to test random samples of &lt;code&gt;Person&lt;/code&gt; data:&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; Main &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Data.Aeson                           (&lt;span class=&quot;type&quot;&gt;FromJSON&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;ToJSON&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;decode&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                       &lt;span class=&quot;title&quot;&gt;encode&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Data.Text.Arbitrary                  ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Test.Framework                       (&lt;span class=&quot;type&quot;&gt;Test&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;defaultMain&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Test.Framework.Providers.QuickCheck2 (&lt;span class=&quot;title&quot;&gt;testProperty&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;           Test.QuickCheck.Arbitrary.Generic    (&lt;span class=&quot;type&quot;&gt;Arbitrary&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;arbitrary&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                       &lt;span class=&quot;title&quot;&gt;genericArbitrary&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                       &lt;span class=&quot;title&quot;&gt;genericShrink&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;shrink&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;personTest&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;personTest&lt;/span&gt; = testProperty &lt;span class=&quot;string&quot;&gt;&quot;Encode and decode a Person&quot;&lt;/span&gt; (jsonProperties :: &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Arbitrary&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  arbitrary = genericArbitrary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  shrink = genericShrink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;jsonProperties&lt;/span&gt; :: (&lt;span class=&quot;type&quot;&gt;Eq&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;ToJSON&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;FromJSON&lt;/span&gt; a) =&amp;gt; a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;jsonProperties&lt;/span&gt; a = &lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt; a == (decode . encode) a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;IO&lt;/span&gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; = defaultMain [personTest]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Now we can be pretty confident about the correctness of our JSON conversions.&lt;/p&gt;
&lt;p&gt;Until I started using Haskell professionally, I wasn’t totally sold on static typing, however it’s examples like these that have converted me. With as little as 7 lines of code we can be sure that the data we are sending over the wire adheres to our API contract at compile time.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Haskell Generics + Aeson + QuickCheck For The Win&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recently I’ve been working on an HTTP API written in Haskell. One of the things that tends to be much easier and nicer in dynamic languages is dealing with JSON in these APIs, statically typed languages tend to have lots of boilerplate. Not only is this boilerplate annoying to write but it can cause small changes to the API into a big task.&lt;/p&gt;
&lt;p&gt;With Haskell (actually GHC) this is not the case.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>The REPL as a business tool</title>
    <link href="http://shmish111.github.io/2016/05/14/the-repl-as-a-business-tool/"/>
    <id>http://shmish111.github.io/2016/05/14/the-repl-as-a-business-tool/</id>
    <published>2016-05-13T23:00:00.000Z</published>
    <updated>2016-05-15T18:45:02.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;The REPL can save hours of pain through pairing with non-technical colleagues.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The boundary between a business user and a developer can often be a big source of waste. Going back and forth between the user and your code to discover what data is really needed can really cause pain and waste a huge amount of time. The REPL can be used as an interactive environment to pair with a user and write the exact code required, first time.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;The-Problem&quot;&gt;&lt;a href=&quot;#The-Problem&quot; class=&quot;headerlink&quot; title=&quot;The Problem &quot;&gt;&lt;/a&gt;The Problem &lt;img src=&quot;/images/soap__large.jpg&quot; alt=&quot;&quot;&gt;&lt;/h2&gt;&lt;p&gt;Recently I was developing a middleware system where data would come in via HTTP as JSON, be converted into SOAP XML and sent to a finance system. As usual, the field names in the finance system were completely different from the system they being provided by. There were spreadsheets which attempted to define this mapping but the system was evolving and the spreadsheet was not always correct. For example, there were 3 different date fields that all sounded very similar, which one should be sent to the finance system?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/m.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;There was a colleague (lets call him ‘M’) who understood how to use both systems and really knew what the data meant, he had the knowledge but he had no idea how to program. After a number of attempts at getting the mapping correct myself, each requiring a build, deploy and test cycle, I was getting a bit frustrated. I had a big screen with the Clojure mapping on one side and a REPL running on the other and I realized that anyone should be able to understand what was going on if they could see the input, the mapping and the output.&lt;/p&gt;
&lt;p&gt;For anyone who has never heard of a REPL before, it stands for ‘Read, Eval, Print, Loop’ and it is basically an interactive console where you can run your code. Lisps generally place a lot of importance on the REPL and Clojure is no exception. It’s one of the things that really makes Clojure great, instead of having to write unit tests or small programs and run them to see what a piece of code does, you can just evaluate it in the REPL, in real time. Check out &lt;a href=&quot;http://www.tryclj.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Try Clojure&lt;/a&gt; to see it in action, follow the instructions at the bottom.&lt;/p&gt;
&lt;h2 id=&quot;A-perfect-match&quot;&gt;&lt;a href=&quot;#A-perfect-match&quot; class=&quot;headerlink&quot; title=&quot;A perfect match&quot;&gt;&lt;/a&gt;A perfect match&lt;/h2&gt;&lt;p&gt;M and I sat together at my desk and I loaded up a sample of incoming data as a Clojure map, keywords to values. The keywords had been generated by the system providing the data so M knew exactly what they meant. I then showed him the current mapping on the left and called the mapping function in the REPL to produce output for that data. M could clearly see where the data had come from and quickly pointed out that the wrong date was being used. A quick change and synchronize the REPL and we tried again.&lt;/p&gt;
&lt;p&gt;This time it was a bit less clear, M could see that something was not right but wasn’t sure which fields were available, the incoming data was a big nested map with vectors of nested maps so it was difficult to distinguish what was what. A bit of &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; with some &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; and a sprinkling of &lt;code&gt;keys&lt;/code&gt; made things clear. The REPL had enabled us to zoom in on data and hide what was unimportant and clouding our vision.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/james.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Our session lasted about 15 minutes and at the end the mapping was 100% correct, I had live confirmation from a user. The code went live and into production and everything now works correctly. It was clear; our short session pairing at the REPL had saved days if not weeks of back and forth, getting things slightly wrong and reading through spreadsheets. It was a lesson that has saved me many more painful hours since and I am sure in the future.&lt;/p&gt;
&lt;h2 id=&quot;Conclusion&quot;&gt;&lt;a href=&quot;#Conclusion&quot; class=&quot;headerlink&quot; title=&quot;Conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;I have not seriously used another language that would have enabled anything like this responsiveness in this particular situation and it has shown me how important it is to use the best programming language for the job. In this case, that language was Clojure.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;The REPL can save hours of pain through pairing with non-technical colleagues.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The boundary between a business user and a developer can often be a big source of waste. Going back and forth between the user and your code to discover what data is really needed can really cause pain and waste a huge amount of time. The REPL can be used as an interactive environment to pair with a user and write the exact code required, first time.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Beating Bugs With Brute Force</title>
    <link href="http://shmish111.github.io/2016/04/27/beating-bugs-with-brute-force/"/>
    <id>http://shmish111.github.io/2016/04/27/beating-bugs-with-brute-force/</id>
    <published>2016-04-26T23:00:00.000Z</published>
    <updated>2016-05-15T13:59:53.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Improve product quality and find bugs faster by generating tests.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For years I’ve been writing the tests for the applications I write however it turns out that computers can do a better job. Property based testing is the doorway to a more advanced world of testing that can dramatically improve quality and find bugs that would have appeared on day 1 in prod.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Generative-Testing&quot;&gt;&lt;a href=&quot;#Generative-Testing&quot; class=&quot;headerlink&quot; title=&quot;Generative Testing&quot;&gt;&lt;/a&gt;Generative Testing&lt;/h2&gt;&lt;p&gt;When you write tests, you will often have to write test data (aka fixtures), for example lets say we have a microservice for dealing with customer details. This is likely a CRUD service so we might write a test that POSTs a new customer and then tries to GET the customer. We will define some sample data to build a new customer request:&lt;/p&gt;
&lt;figure class=&quot;highlight clj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; a-customer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;David Smith&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;symbol&quot;&gt;:age&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;symbol&quot;&gt;:gender&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;male&quot;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;We can then re-use this in various different tests. We may even turn this into a function to try to vary the details for certain tests:&lt;/p&gt;
&lt;figure class=&quot;highlight clj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; a-customer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [m]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;merge&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;&quot;David Smith&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;symbol&quot;&gt;:age&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;symbol&quot;&gt;:gender&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;male&quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         m))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;An alternative would be to use generators to create our data:  &lt;/p&gt;
&lt;figure class=&quot;highlight clj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; a-customer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;gen/hash-map&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt; gen/string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;symbol&quot;&gt;:age&lt;/span&gt; gen/int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;symbol&quot;&gt;:gender&lt;/span&gt; gen/string))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;deftest&lt;/span&gt; my-test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;let&lt;/span&gt;&lt;/span&gt; [new-customer (&lt;span class=&quot;name&quot;&gt;gen/generate&lt;/span&gt; a-customer)]))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The &lt;code&gt;gen&lt;/code&gt; namespace is part of a Clojure library called &lt;a href=&quot;https://github.com/clojure/test.check&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;test.check&lt;/a&gt; which provides functions for generating random data. For example, &lt;code&gt;gen/string&lt;/code&gt; will generate a random string, &lt;code&gt;gen/int&lt;/code&gt; will generate a random integer etc.&lt;/p&gt;
&lt;p&gt;So why would you use the generated version? First it means you don’t have to waste your time coming up with witty values but more importantly you are more correctly defining how your function works. In production, the service will not always receive a customer whose name is “David Smith”, it will receive a name whose value is a string. With a generator we state this explicitly. On top of that, generators tend to generate loads of rubbish that can screw with your functions surprisingly quickly; I’ve found quite a few bugs the first time I hit the service with generated data.&lt;/p&gt;
&lt;p&gt;Generators can be a bit daunting at first, I thought that they may become so complicated that you would need to test your generators! It turns out though that this is not the case and property testing libraries like test.check have the tools to generate just about anything fairly easily. You can also come up with your own patterns and helpers to make things easier. One of the best examples of this is Plumatic Schema’s experimental generators.&lt;/p&gt;
&lt;p&gt;Given any schema, the library will provide you with a generator to generate values that conform to this schema. If you are already validating your new customer in the microservice using schema then there is really no work involved:&lt;/p&gt;
&lt;figure class=&quot;highlight clj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;defschema&lt;/span&gt; Customer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt; s/Str&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;symbol&quot;&gt;:age&lt;/span&gt; s/Int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;symbol&quot;&gt;:gender&lt;/span&gt; s/Str&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;sg/generate&lt;/span&gt; Customer)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;It really is as simple as that, we’ve eliminated the tedious work of writing sample data and at the same time we’ve increased the scope for finding bugs.&lt;/p&gt;
&lt;h2 id=&quot;Property-Based-Testing&quot;&gt;&lt;a href=&quot;#Property-Based-Testing&quot; class=&quot;headerlink&quot; title=&quot;Property Based Testing&quot;&gt;&lt;/a&gt;Property Based Testing&lt;/h2&gt;&lt;p&gt;Property based testing is a method of testing functions pioneered by the Haskell community. From Hackage:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;QuickCheck is a library for random testing of program properties.&lt;/p&gt;
&lt;p&gt;The programmer provides a specification of the program, in the form of properties which functions should satisfy, and QuickCheck then tests that the properties hold in a large number of randomly generated cases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Property based testing libraries such as test.check have 2 distinct parts. The first part is a framework for random value generation as we saw above, the second part is a clever test runner that will try to find the simplest failing case.&lt;/p&gt;
&lt;p&gt;As a simple example taken directly from the test.check README.md, lets say you have a function called &lt;code&gt;sort&lt;/code&gt; which will reverse a vector of integers. You provide a generator which will generate vectors of random sizes containing random integers, you then use these as inputs into your functions. Finally you provide a set of properties that should hold true, in this example we can say that reversing a list twice should result in the original list. A library such as QuickCheck or Clojure’s &lt;code&gt;test.check&lt;/code&gt; will then try to find an example that will cause the test to fail by generating hundreds or thousands of test cases.&lt;/p&gt;
&lt;figure class=&quot;highlight clj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; sort-idempotent-prop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;prop/for-all&lt;/span&gt; [v (&lt;span class=&quot;name&quot;&gt;gen/vector&lt;/span&gt; gen/int)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;=&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;sort&lt;/span&gt;&lt;/span&gt; v) (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;sort&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;sort&lt;/span&gt;&lt;/span&gt; v)))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;tc/quick-check&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; sort-idempotent-prop)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;;; =&amp;gt; &amp;#123;:result true, :num-tests 100, :seed 1382488326530&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;This all sounds great however all the online examples are testing small, pure functions that are only a small part of the software we write. Impressive as it is, I was struggling to see how often I would use this type of testing in my everyday development of systems such as HTTP microservices, which often have limited functionality and not much complex logic. However that all changed once I started to have go!&lt;/p&gt;
&lt;h2 id=&quot;You-wanna-play-rough&quot;&gt;&lt;a href=&quot;#You-wanna-play-rough&quot; class=&quot;headerlink&quot; title=&quot;You wanna play rough?&quot;&gt;&lt;/a&gt;You wanna play rough?&lt;/h2&gt;&lt;p&gt;In a recent project we had built a microservice that would take a request through a RESTful interface, provide a small amount of validation and the place the result on RabbitMQ. For this microservice we had chosen the excellent Yada library to take care of all the HTTP/REST infrastructure for us.&lt;/p&gt;
&lt;p&gt;The service wouldn’t be used in a particularly intensive way however the team felt that it would be a good idea to write some load tests to see at what point it falls down and what happens when it does.&lt;/p&gt;
&lt;h2 id=&quot;Say-hello-to-my-little-friend&quot;&gt;&lt;a href=&quot;#Say-hello-to-my-little-friend&quot; class=&quot;headerlink&quot; title=&quot;Say hello to my little friend!&quot;&gt;&lt;/a&gt;Say hello to my little friend!&lt;/h2&gt;&lt;p&gt;We decided to use clj-gatling for our load testing. This is a clojure testing tool which is designed primarily for hitting servers with thousands of requests in parallel and producing nice reports about what happened. Since we had already written integration tests to check the functionality of the service (using &lt;code&gt;test.check&lt;/code&gt;), it was simply a matter of reusing these tests in a slightly modified manner. We would hit the service on a few of the endpoints and check that the appropriate messages were present on the Rabbit queue. I knew that both RabbitMQ and the aleph server that yada uses were designed for high performance so I imagined that we would have to really push things to see any problems, after all, we had already verified that the service worked reliably with the integration tests.&lt;/p&gt;
&lt;figure class=&quot;highlight clj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;deftest&lt;/span&gt; load-test-all-endpoints&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;let&lt;/span&gt;&lt;/span&gt; [&amp;#123;&lt;span class=&quot;symbol&quot;&gt;:keys&lt;/span&gt; [api-root test-config]&amp;#125; (&lt;span class=&quot;name&quot;&gt;test-common/load-config&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;g/run-simulation&lt;/span&gt; [&amp;#123;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt;     &lt;span class=&quot;string&quot;&gt;&quot;sequentially try each endpoint&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;symbol&quot;&gt;:requests&lt;/span&gt; [&amp;#123;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Put user on queue&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &lt;span class=&quot;symbol&quot;&gt;:fn&lt;/span&gt;   (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;partial&lt;/span&gt;&lt;/span&gt; post-user api-root)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                   &amp;#123;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Put articles queue&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &lt;span class=&quot;symbol&quot;&gt;:fn&lt;/span&gt;   (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;partial&lt;/span&gt;&lt;/span&gt; post-articles-csv api-root)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                   &amp;#123;&lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;hit health check endoint&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    &lt;span class=&quot;symbol&quot;&gt;:fn&lt;/span&gt;   (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;partial&lt;/span&gt;&lt;/span&gt; health-check api-root)&amp;#125;]&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      (&lt;span class=&quot;symbol&quot;&gt;:users&lt;/span&gt; test-config)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      &amp;#123;&lt;span class=&quot;symbol&quot;&gt;:requests&lt;/span&gt; (&lt;span class=&quot;symbol&quot;&gt;:requests&lt;/span&gt; test-config)&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;let&lt;/span&gt;&lt;/span&gt; [total-tests (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; @post-user-count @post-articles-csv-count)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      (&lt;span class=&quot;name&quot;&gt;is&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;count&lt;/span&gt;&lt;/span&gt; @errors)) (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;format&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;some requests failed e.g. %s&quot;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;first&lt;/span&gt;&lt;/span&gt; @errors)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      (&lt;span class=&quot;name&quot;&gt;eventually-is&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;=&lt;/span&gt;&lt;/span&gt; total-tests (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;count&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;keys&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;deref&lt;/span&gt;&lt;/span&gt; test-common/msgs)))) (&lt;span class=&quot;symbol&quot;&gt;:message-timeout&lt;/span&gt; test-config)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;format&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;all messages should be received within %sms&quot;&lt;/span&gt; (&lt;span class=&quot;symbol&quot;&gt;:message-timeout&lt;/span&gt; test-config))))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Who-put-this-thing-together&quot;&gt;&lt;a href=&quot;#Who-put-this-thing-together&quot; class=&quot;headerlink&quot; title=&quot;Who put this thing together?&quot;&gt;&lt;/a&gt;Who put this thing together?&lt;/h2&gt;&lt;p&gt;In the first run I decided to hit the service with 1000 requests from 10 ‘users’ in parallel. One of the endpoints was a CSV file upload and I was surprised to find that some of the messages from this endpoint had not appeared on the queue. My initial reaction was that perhaps there was a small overhead getting messages on to Rabbit and although throughput would be high, I might need to give a bit of time after the test had fired it’s requests to see all the results. However I discovered that the messages were simply not getting put on the Rabbit queue, they were just disappearing.&lt;/p&gt;
&lt;p&gt;With some old-school ‘print line’ debugging, it was possible to see that request was getting in to the server but the body was not appearing in my yada handler. This would happen for about 0.5% - 1% of requests, which of course we would never have found with our integration tests. Perhaps occasionally we would have a failed Jenkins build but run it again and everything would pass, it would, in all probability, be put down to something weird on the Jenkins slave and be ignored. We would have lost data in production at some point.&lt;/p&gt;
&lt;h2 id=&quot;Lesson-number-one-Lesson-number-two&quot;&gt;&lt;a href=&quot;#Lesson-number-one-Lesson-number-two&quot; class=&quot;headerlink&quot; title=&quot;Lesson number one; Lesson number two&quot;&gt;&lt;/a&gt;Lesson number one; Lesson number two&lt;/h2&gt;&lt;p&gt;Firstly, this made us realise that we should give a 400 response if the body was empty, something we had failed to think about. Next, careful investigation revealed that the library yada was using for finding multipart boundaries was broken. As a side note, this library was a prime candidate for property based testing and it would have revealed this bug. Malcom, the author of yada promptly wrote his own implementation of the Boyer-Moore search algorithm to fix the issue. We ran the tests again but we saw the same failures! Working with Malcom we found that under certain circumstances, the logic of piecing together the chunks of an uploaded file was incorrect. The issue was fixed and finally the tests passed, we were able to push the service until we finally ran out of file descriptors.&lt;/p&gt;
&lt;h2 id=&quot;Now-you’re-talking-to-me-baby&quot;&gt;&lt;a href=&quot;#Now-you’re-talking-to-me-baby&quot; class=&quot;headerlink&quot; title=&quot;Now you’re talking to me baby!&quot;&gt;&lt;/a&gt;Now you’re talking to me baby!&lt;/h2&gt;&lt;p&gt;So what did I learn from this experience?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Load tests are important, they can test more than just performance.&lt;/li&gt;
&lt;li&gt;Generative tests are vital and can find bugs that would have resulted in loss of revenue.&lt;/li&gt;
&lt;li&gt;Even wearing a QA hat, we can miss simple failure scenarios that should be planned for and dealt with appropriately (the 400 response in this case).&lt;/li&gt;
&lt;li&gt;It’s vital to use libraries that are either battle tested or that are actively maintained so that bugs can be fixed promptly.&lt;/li&gt;
&lt;li&gt;Property based testing should be applied where possible, especially when it comes to algorithm implementations such as the Boyer-Moore search.&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Improve product quality and find bugs faster by generating tests.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For years I’ve been writing the tests for the applications I write however it turns out that computers can do a better job. Property based testing is the doorway to a more advanced world of testing that can dramatically improve quality and find bugs that would have appeared on day 1 in prod.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Either monad or exceptions</title>
    <link href="http://shmish111.github.io/2015/12/15/either-monad-or-exceptions/"/>
    <id>http://shmish111.github.io/2015/12/15/either-monad-or-exceptions/</id>
    <published>2015-12-15T00:00:00.000Z</published>
    <updated>2016-05-14T18:14:52.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;Either&lt;/code&gt; monad from &lt;a href=&quot;https://github.com/funcool/cats&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cats&lt;/a&gt; is pretty cool.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recently I was asked to complete a small test for a job interview in the form of a Clojure program. The idea of the program was to take commands from stdin and use them to mess around with a ‘canvas’, basically a super-primitive graphics program. It occured to me that since part of this would involve parsing and validating commands and displaying any errors, it might be a good opportunity to use the Either monad and see the current state of monad libraries in Clojure.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;I have used &lt;a href=&quot;https://github.com/clojure/algo.monads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;algo.monads&lt;/a&gt; in the past but looking at the project on github I could see that it hadn’t been updated in more than 11 months. I thought that perhaps there has been some work done in this area since then and I discovered &lt;a href=&quot;https://github.com/funcool/cats&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cats&lt;/a&gt;. It has some nice documentation and a nice philosophy so I decided to give it a try.&lt;/p&gt;
&lt;p&gt;The program flow is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read-line from the console&lt;/li&gt;
&lt;li&gt;split the input by the space character&lt;/li&gt;
&lt;li&gt;dispatch the arguments and the current state of the program to a multi-method, based on the first argument&lt;/li&gt;
&lt;li&gt;return the new state or a string to display on the console&lt;/li&gt;
&lt;li&gt;loop round to read-line again&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This flow allows me to use pure functions for the multi-method as in the following command which flood-fills an area of the canvas:&lt;/p&gt;
&lt;figure class=&quot;highlight clj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; valid-number-of-args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [args n]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;if&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;=&lt;/span&gt;&lt;/span&gt; n (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;count&lt;/span&gt;&lt;/span&gt; args))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;right&lt;/span&gt; args)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;left&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;str&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;invalid number of arguments, expected &quot;&lt;/span&gt; n))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defmethod&lt;/span&gt;&lt;/span&gt; do-command &lt;span class=&quot;string&quot;&gt;&quot;F&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [_ state &amp;amp; args]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;m/mlet&lt;/span&gt; [[x y colour] (&lt;span class=&quot;name&quot;&gt;valid-number-of-args&lt;/span&gt; args &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           pixel (&lt;span class=&quot;name&quot;&gt;valid-pixel&lt;/span&gt; state x y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           _ (&lt;span class=&quot;name&quot;&gt;valid-colour&lt;/span&gt; colour)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          (&lt;span class=&quot;name&quot;&gt;m/return&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;flood-fill&lt;/span&gt; pixel colour state))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;mlet&lt;/code&gt; is analogous to do notation in Haskell. &lt;code&gt;valid-number-of-args&lt;/code&gt;, &lt;code&gt;valid-pixel&lt;/code&gt; and &lt;code&gt;valid-colour&lt;/code&gt; are functions that return either a &lt;code&gt;Right&lt;/code&gt; containing the value or a &lt;code&gt;Left&lt;/code&gt; containing an error.&lt;/p&gt;
&lt;p&gt;It’s probably clear that I could have used functions that throw an Exception with the error message, the above would then look like:&lt;/p&gt;
&lt;figure class=&quot;highlight clj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; valid-number-of-args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [args n]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;if&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;=&lt;/span&gt;&lt;/span&gt; n (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;count&lt;/span&gt;&lt;/span&gt; args))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;throw&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;Exception.&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;str&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;invalid number of arguments, expected &quot;&lt;/span&gt; n)))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defmethod&lt;/span&gt;&lt;/span&gt; do-command &lt;span class=&quot;string&quot;&gt;&quot;F&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [_ state &amp;amp; args]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;let&lt;/span&gt;&lt;/span&gt; [[x y colour] (&lt;span class=&quot;name&quot;&gt;valid-number-of-args&lt;/span&gt; args &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pixel (&lt;span class=&quot;name&quot;&gt;valid-pixel&lt;/span&gt; state x y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _ (&lt;span class=&quot;name&quot;&gt;valid-colour&lt;/span&gt; colour)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (&lt;span class=&quot;name&quot;&gt;flood-fill&lt;/span&gt; pixel colour state)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;You could argue that the second version, apart from being slightly more terse, is more idiomatic however I don’t believe this is true, Exceptions in Java were never intended to be used for unexceptional flow, it’s just that they have become commonly used in this way, precisely because they are basically a strange form of the Either monad, why not just use the real thing when dealing with non-exceptional flow? It also looks better if you can avoid instantiating java classes such as &lt;code&gt;Exception&lt;/code&gt; in my opinion.&lt;/p&gt;
&lt;p&gt;In this particular case the flow is not ‘exceptional’ at all since some of the commands such as ‘S’ which displays the current state on the console, should return a string even though there is no ‘error’. Having a function that always throws an &lt;code&gt;Exception&lt;/code&gt; and yet is successful seems a bit dodgy to me. With &lt;code&gt;Either&lt;/code&gt; you are not saying that &lt;code&gt;Left&lt;/code&gt; are errors but rather that they are strings that should be displayed to the user.&lt;/p&gt;
&lt;p&gt;I have also been using promises in the form of &lt;a href=&quot;https://github.com/ztellman/manifold&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;manifold&lt;/a&gt; a lot recently and the semantics of this are almost exactly the same as &lt;code&gt;Either&lt;/code&gt; and &lt;code&gt;mlet&lt;/code&gt; above, a manifold &lt;code&gt;deferred&lt;/code&gt; is essentially an async &lt;code&gt;Either&lt;/code&gt;. Add to this that manifold can be used with cats and it adds up to a more consistent way of doing things. Everything looks the same, it’s just a matter of whether you want something to be async or not.&lt;/p&gt;
&lt;p&gt;Finally, because an &lt;code&gt;Exception&lt;/code&gt; will keep going up the call-chain until it is caught, it’s possible to introduce bugs where the &lt;code&gt;Execption&lt;/code&gt; disappears into the ether, this can be a pain to discover sometimes. Using the &lt;code&gt;Either&lt;/code&gt; semantics, Clojure’s type system will usually throw a runtime exception and problems will be slightly easier to spot.&lt;/p&gt;
&lt;p&gt;My conclusion is that I like using &lt;code&gt;Either&lt;/code&gt; in Clojure and I like cats :) I think I will use both in the future. It’s also nice to note that cats and some related libraries are moving Clojure in directions other than what the clojure.core team is doing. As clojure.core gets better and more innovative, the libraries and tools do as well. It makes me glad to be using Clojure and hopeful for it’s future.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;Either&lt;/code&gt; monad from &lt;a href=&quot;https://github.com/funcool/cats&quot;&gt;cats&lt;/a&gt; is pretty cool.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recently I was asked to complete a small test for a job interview in the form of a Clojure program. The idea of the program was to take commands from stdin and use them to mess around with a ‘canvas’, basically a super-primitive graphics program. It occured to me that since part of this would involve parsing and validating commands and displaying any errors, it might be a good opportunity to use the Either monad and see the current state of monad libraries in Clojure.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Static vs Dynamic</title>
    <link href="http://shmish111.github.io/2014/09/09/static-vs-dynamic/"/>
    <id>http://shmish111.github.io/2014/09/09/static-vs-dynamic/</id>
    <published>2014-09-08T23:00:00.000Z</published>
    <updated>2016-03-25T10:05:42.000Z</updated>
    
    <content type="html">&lt;p&gt;I have recently moved jobs and now I am using Clojure rather than Java and Scala. Before starting I had been reading up on the static vs dynamic typing argument. I enjoy all the type stuff, when you start learning Haskell and Scala there’s some really interesting things to learn and some parts of static typing can really help. Most notable for me is function signatures, I really find function signatures to be one of the best things about static typing.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;Once I started using Clojure, however, I was amazed how productive and fun it was. Using functional Scala and Haskell makes you feel clever and when you get something working it’s really satisfying, using Clojure though is just plain fun! It’s so productive, the feedback is instant (I’d recommend trying Light Table with it’s inline evaluation) and you don’t have to fight against the type system.&lt;/p&gt;
&lt;p&gt;Of course this comes at a cost, the main downsides supposedly being&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;difficult to understand and navigate a large codebase&lt;/li&gt;
&lt;li&gt;lack of refactoring in tooling&lt;/li&gt;
&lt;li&gt;it’s slow&lt;/li&gt;
&lt;li&gt;minor bugs that would have been caught by the type checker&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The company I moved to has a fairly large and complex codebase of a reasonable age (around 4 years) but I was amazed at how easy it was to understand and navigate. I have no doubt that you could make something truly incomprehensible with Clojure but the thing is it doesn’t actually lend itself to this.&lt;/p&gt;
&lt;p&gt;First of all it’s pretty terse: Before I started my new job I re-wrote a program in Clojure that I had recently written in Groovy. I compared a function for manipulating some data that was reasonably complex, both the Groovy and the Clojure version were the same size in terms of lines of code. However the Groovy project was around 1300 lines of code verses around 350 for the Clojure project! This suggests to me that a huge amount of space was taken up by the Java-style boilerplate code required, lets multiply that by 10 and imagine how easy a codebase of 3000 lines is to understand compared to 13000… I have no doubt that a Java version would have been even worse.&lt;/p&gt;
&lt;p&gt;Something else about the maintainability of a decent size codebase in Clojure is that the culture is that of making small, specific libraries and spending time thinking about the API of these libraries. This leads to quite a lot of projects but good separation of concerns. It also makes it easier to open source parts of your codebase.&lt;/p&gt;
&lt;p&gt;Moving on to refactoring and tooling, I definitely found there were a few refactoring features I missed, find usages in a project was the biggest one. However I found, as I had read, that with Clojure, text manipulation is far more important than cross-file refactoring. I didn’t really miss much and there’s a lot to be said for weak autocomplete actually forcing you to understand the code better.&lt;/p&gt;
&lt;p&gt;Speed is an interesting one. Clojure can be optimized to be not far off the speed of Java however you sacrifice idiomaticity and it will never be quite as fast. The thing is though that this single thread speed is not often a requirement, especially as Clojure makes parallelism much easier. When it becomes an issue though, it is quite easy to integrate Java for performance, a good quote is from the http-kit blog, “Clojure + JAVA = Performance + Nice API”.&lt;/p&gt;
&lt;p&gt;Finally we come to bugs. I’m not sure about this, I imagine it’s true but I haven’t been working with Clojure long enough to see. So far I haven’t come across a bug that would not have existed with a type checker but that’s just circumstantial.&lt;/p&gt;
&lt;p&gt;Perhaps in a few years I’ll change my mind but for now I’m sold on the advantages of dynamic languages and I’m embarrassed to say that I have even become a bit of a Clojure fan-boy :(&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;I have recently moved jobs and now I am using Clojure rather than Java and Scala. Before starting I had been reading up on the static vs dynamic typing argument. I enjoy all the type stuff, when you start learning Haskell and Scala there’s some really interesting things to learn and some parts of static typing can really help. Most notable for me is function signatures, I really find function signatures to be one of the best things about static typing.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Consistency is not the key</title>
    <link href="http://shmish111.github.io/2014/07/09/consistency-is-not-the-key/"/>
    <id>http://shmish111.github.io/2014/07/09/consistency-is-not-the-key/</id>
    <published>2014-07-08T23:00:00.000Z</published>
    <updated>2016-03-25T10:06:30.000Z</updated>
    
    <content type="html">&lt;p&gt;Everyone’s heard it, probably everyone’s said it and on the face of it it makes sense, “We need a consistent approach”, “Consistency will make our code more maintainable”, “Consistency will make it easier for new joiners to understand the code”. These days though, when it comes to software development, I’ve learnt to question everything and I’m questioning this attitude.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;TL;DR Consistency certainly has a place in development but it should never restrict innovation and improvement.&lt;/p&gt;
&lt;p&gt;The problem I have with consistency is that I find what it usually means is consistently doing something in a legacy way. Lets take tools as an example.&lt;/p&gt;
&lt;p&gt;In one project, I was pushing for a move from subversion to git. Some of our projects had a problem with git so we had 3 choices:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find a solution to the problem&lt;/li&gt;
&lt;li&gt;Leave the problematic projects in subversion and move the rest to git&lt;/li&gt;
&lt;li&gt;Stay using subversion&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Option 1 is ideal but it may take too long or perhaps not even be possible right now.&lt;br&gt;Option 2 enables us to improve the way we work but we will have 2 places to go to to find our code.&lt;br&gt;Option 3 is avoiding innovation to maintain consistency. We are conciously deciding to limit the scope with which we can improve our workflows and dev ops process, among other things.&lt;/p&gt;
&lt;p&gt;For me it’s obvious, start with option 2 and move to option 1 if you can.&lt;/p&gt;
&lt;p&gt;Next we can look at code; instead of driving consistency, drive idiomaticity. Idiomatic code is consistent, but it’s much more than that, it’s a way of writing your code that many people better than us have come to agree is usually best. The word idiomatic doesn’t seem to be used much in the Java/C# world but you find it all the time in functional language communities. Idiomatic code is not just consistent within your team, it’s consistent within the community. It is not however, consistent in time. Idioms evolve with a language, they are always up to date but that means you also need to stay up to date.&lt;/p&gt;
&lt;p&gt;On to architecture. This is the area where there is probably the most bad consistency. I think some people think of architecture as something that should be decided upon once at the start of a big project and we should stick with it through thick and thin because architecture is hard to change. To that I say, if it’s hard to change then it’s not a good architecture and you should improve it. Architecture is the enabler of improvement, that is why it’s so crucial to agile development. It is also evolving quickly, new technologies and new ideas lead to new ways of architecting systems. An architecture that seemed pretty good five years ago is almost definitely not the best way to do things now (although a lot of the concepts will still be the same).&lt;/p&gt;
&lt;p&gt;Finally we have team process. Consistency here should be used in a different way. New ideas need to be given a chance before they are either accepted or modified. You should maintain consistency in the majority of your process whilst you pick areas to expermint with. Just make sure you consistently try new ideas!&lt;/p&gt;
&lt;p&gt;Technology evolves so quickly that finding a good way of doing something and sticking with it means you are effectively going backwards. If you don’t make improvements to each of the 4 areas mentioned above every day then you will quickly find yourself in a legacy world of pain and you will not be able to keep up with the competition.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Everyone’s heard it, probably everyone’s said it and on the face of it it makes sense, “We need a consistent approach”, “Consistency will make our code more maintainable”, “Consistency will make it easier for new joiners to understand the code”. These days though, when it comes to software development, I’ve learnt to question everything and I’m questioning this attitude.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Coding is easy, software development is hard</title>
    <link href="http://shmish111.github.io/2014/07/07/coding-is-easy/"/>
    <id>http://shmish111.github.io/2014/07/07/coding-is-easy/</id>
    <published>2014-07-06T23:00:00.000Z</published>
    <updated>2017-03-18T16:46:06.000Z</updated>
    
    <content type="html">&lt;p&gt;Software developers like to write code. Well that makes sense but software development is the process of delivering working code to an environment where it provides value to a user. In my experience, a developer will generally spend their time doing the following tasks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Requirements Gathering&lt;/li&gt;
&lt;li&gt;Writing code&lt;/li&gt;
&lt;li&gt;Manual testing&lt;/li&gt;
&lt;li&gt;Releasing&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
This is what happens even though you have dedicated QA, operations and business analysts and with good reason. Testing, releasing and requirements gathering need the input of the people who write the code. There is no escape, it doesn’t matter whether you are writing your own app or working as part of a massive team, it’s a critical part of the process. What’s more is that in the most successful teams that I’ve worked in, coding took up less of my time than the other 3 tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So embrace it. Test and release automation are complex and should be interesting for people who enjoy writing software. Requirements gathering? Well it is what you make of it I guess. It can be really rewarding to build good relationships with the stakeholders and to learn about the business in which you are working.&lt;/p&gt;
&lt;p&gt;As an individual, if you do not embrace these tasks then you will forever be unhappy as you will be forced to do things that you don’t want to do. If as a team you do not embrace them then you will end up with bottlenecks at the boundaries between the tasks, you will not get software to production as quickly as you otherwise could, it will have more bugs and it will be less suited to what the user really needs.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Software developers like to write code. Well that makes sense but software development is the process of delivering working code to an environment where it provides value to a user. In my experience, a developer will generally spend their time doing the following tasks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Requirements Gathering&lt;/li&gt;
&lt;li&gt;Writing code&lt;/li&gt;
&lt;li&gt;Manual testing&lt;/li&gt;
&lt;li&gt;Releasing
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>The Trouble With Scrum</title>
    <link href="http://shmish111.github.io/2014/06/24/the-trouble-with-scrum/"/>
    <id>http://shmish111.github.io/2014/06/24/the-trouble-with-scrum/</id>
    <published>2014-06-23T23:00:00.000Z</published>
    <updated>2016-03-25T10:06:58.000Z</updated>
    
    <content type="html">&lt;p&gt;In Scrum (and other time-boxed methods) a commitment is made at the start of the sprint to complete a certain amount of work.  This approach encourages on-time delivery of features, a team only commits to what it thinks it can do based on previous iterations and it makes sure this is delivered.  If things got a bit close towards the end then in the next sprint they should commit to a bit less and visa versa.  This seems like a noble and pragmatic approach at first however there are some flaws, mostly due to human nature.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;Most people want to meet their commitments, that’s the whole idea, so what happens when things get a bit tight towards the end of the sprint, what is sacrificed in order to meet those commitments?  For most people it’s always going to be quality.  It makes sense, it’s the only thing you have available to sacrifice really and it can be fixed later.  So lets move to the next sprint, in planning a commitment should be made to fix the lack of quality of the last sprint, you over-estimated and so pushed some of the work into the next sprint.&lt;/p&gt;
&lt;p&gt;The problem is that this rarely happens, new features are alluring and the time taken to remove this quality debt can easily be under-estimated.  This debt repayment is again left over as the sprint draws to a close and eventually it disappears into the unknown.  What this has resulted in is variation in quality and to make things worse, this variation inevitably leads to a degradation in overall quality and over time lack of quality reduces a team’s velocity.&lt;/p&gt;
&lt;p&gt;So what’s the solution?  First, agree on a consistent level of quality.  Things do not have to be perfect but they should meet consistent, well defined criteria.  This level can hopefully be increased over time as the team becomes better at ensuring quality.&lt;/p&gt;
&lt;p&gt;Second, this quality level must become part of the definition of done.  Usually done definitions include something vague about the level of testing but this needs to be more explicit and defined in terms of real metrics, processes and practices which a feature must meet in order to be done.&lt;/p&gt;
&lt;p&gt;Lastly, consider changing iterations from being time based to feature based, the most common approach being kanban.  There are many advantages to developing and releasing around features rather than time, not least of which is reducing the temptation to sacrifice quality in order to meet a self-imposed deadline.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;In Scrum (and other time-boxed methods) a commitment is made at the start of the sprint to complete a certain amount of work.  This approach encourages on-time delivery of features, a team only commits to what it thinks it can do based on previous iterations and it makes sure this is delivered.  If things got a bit close towards the end then in the next sprint they should commit to a bit less and visa versa.  This seems like a noble and pragmatic approach at first however there are some flaws, mostly due to human nature.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Too many Whens</title>
    <link href="http://shmish111.github.io/2014/06/07/too-many-whens/"/>
    <id>http://shmish111.github.io/2014/06/07/too-many-whens/</id>
    <published>2014-06-06T23:00:00.000Z</published>
    <updated>2016-03-25T10:07:12.000Z</updated>
    
    <content type="html">&lt;p&gt;I’ve put in quite a lot of effort learning about automated testing in the last few years and have become quite passionate (some may say opinionated) about the subject.  Through trial and error, reading and working with some experienced QAs, I’ve formed some rules for myself about how I write BDD style tests.  I’d like to share one of these as I can’t find anything on the internet that suggests or explains it.  The rule is:&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;A scenario should only ever have one ‘When’ statement.&lt;/p&gt;
&lt;p&gt;Consider the scenario below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given a user logs in
And the user is an administrator
When they click on &amp;apos;my profile&amp;apos;
And they click on &amp;apos;view my cart&amp;apos;
Then their shopping cart should be displayed
When they click on an item
Then the item details should be displayed
And the price should be displayed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I’ve seen similar scenarios to this many times. It could be made a lot clearer by applying the ‘When’ rule:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given a user logs in
And the user is an administrator
When they click on &amp;apos;my profile&amp;apos;
Then the &amp;apos;view my cart&amp;apos; button is displayed

Given an administrator is on the &amp;apos;view cart&amp;apos; page
And the cart contains items
When they click on an item
Then the item details should be displayed
And the price should be displayed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to apply the rule it was necessary to split the scenario into two.  With a bit of practice and attention you eventually see that every scenario can be viewed as a state transition.  The system starts in state A, an action is performed, the system is now in state B.  Uncle Bob wrote about this way back in 2008 &lt;a href=&quot;https://sites.google.com/site/unclebobconsultingllc/the-truth-about-bdd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Truth About BDD&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I challenge you to find a feature that is not clearer and easier to understand when it has only one When in each scenario.&lt;/p&gt;
&lt;p&gt;That’s all well and good when we are just writing specifications, but what happens when we start to use these specifications as automated tests? There is a weakness in this method; by ensuring only one thing is tested at a time, the state of the system needs to be set up more often.  For example, in the scenarios above we will need to log in to the system twice instead of once, a UI automation task that could be quite expensive and slow down our test suite.&lt;/p&gt;
&lt;p&gt;In some situations it is just not practical to do this and clarity and detail must be sacrificed in order to make the tests usable.  However I feel that too often people will state this reason, do more manual testing, produce lower quality software and become less agile when perhaps they could spend some of this time working on ways to speed up the test suite.&lt;/p&gt;
&lt;p&gt;Have a go writing your scenarios using this rule and see what happens.  If you think it’s not practical for some of your tests, challenge your team to make the tests run faster, by parallelizing them for example (I’ve got some ideas on this I’ll put in another post).&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;I’ve put in quite a lot of effort learning about automated testing in the last few years and have become quite passionate (some may say opinionated) about the subject.  Through trial and error, reading and working with some experienced QAs, I’ve formed some rules for myself about how I write BDD style tests.  I’d like to share one of these as I can’t find anything on the internet that suggests or explains it.  The rule is:&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Stupid developers!</title>
    <link href="http://shmish111.github.io/2014/06/07/stupid-developers/"/>
    <id>http://shmish111.github.io/2014/06/07/stupid-developers/</id>
    <published>2014-06-06T23:00:00.000Z</published>
    <updated>2016-03-25T10:07:23.000Z</updated>
    
    <content type="html">&lt;p&gt;In my continuous quest to learn how to develop better software I’ve been reading a lot of articles warning us of the risks of ‘using Agile’. Often these articles or their comments have something along the lines of, “there are 3 types of developers, the bright ones, the normal ones and the stupid ones. The bright ones will make any methodology work and the stupid ones will make any methodology fail so we have to look out for ‘normal’ developers…”. Every time I read this it frustrates and annoys me so I thought I’d make my feelings public in the hope that someone will benefit from my opinion.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;In my time as a software developer I haven’t yet met a developer who isn’t bright. I have though, been in the position where I was considered to be the weak link in the team and almost didn’t pass my probationary period. I have since been told I was “the biggest talent”. What happened to me to go from one end of the spectrum to the other? I went from working under high pressure at a finance software consultancy where everything was waterfall, software quality was not high and nobody had heard of the agile manifesto to working for an open-minded, enthusiastic and fun website. This agile environment enabled me to be more creative and increased my confidence which in turn lead me to learn faster and become a much better developer who could provide more value to the team. Agile development is about getting the most out of a team, using an Agile (with a capital A) process is only a small part of this.&lt;/p&gt;
&lt;p&gt;If a team isn’t producing, don’t blame it on the process or team members, first ask, “is the team happy and are they encouraged to be creative”? I would hazard a guess that more often than not the answers are no and I am absolutely sure that if you change this then your team will improve rapidly.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;In my continuous quest to learn how to develop better software I’ve been reading a lot of articles warning us of the risks of ‘using Agile’. Often these articles or their comments have something along the lines of, “there are 3 types of developers, the bright ones, the normal ones and the stupid ones. The bright ones will make any methodology work and the stupid ones will make any methodology fail so we have to look out for ‘normal’ developers…”. Every time I read this it frustrates and annoys me so I thought I’d make my feelings public in the hope that someone will benefit from my opinion.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
