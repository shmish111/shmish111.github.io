<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Safe JSON with Haskell · Continuously Improving</title><meta name="description" content="Safe JSON with Haskell - David Smith"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/shmish111" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Safe JSON with Haskell</h1><div class="post-time">Mar 18, 2017</div><div class="post-content"><blockquote>
<p>Haskell Generics + Aeson + QuickCheck For The Win</p>
</blockquote>
<p>Recently I’ve been working on an HTTP API written in Haskell. One of the things that tends to be much easier and nicer in dynamic languages is dealing with JSON in these APIs, statically typed languages tend to have lots of boilerplate. Not only is this boilerplate annoying to write but it can cause small changes to the API into a big task.</p>
<p>With Haskell (actually GHC) this is not the case.<br><a id="more"></a><br>A great GHC extension is <a href="https://ocharles.org.uk/blog/posts/2014-12-16-derive-generic.html" target="_blank" rel="external">DeriveGeneric</a> which can be used to define how to generate type class instances. <a href="https://hackage.haskell.org/package/aeson" target="_blank" rel="external">Aeson</a> has made great use of this, lets look at the following example:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveGeneric #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> Lib <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GHC.Generics</span><br><span class="line"><span class="keyword">import</span> Data.Aeson</span><br><span class="line"><span class="keyword">import</span> Data.Text</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123;</span><br><span class="line">      <span class="title">name</span> :: <span class="type">Text</span></span><br><span class="line">    , <span class="title">age</span>  :: <span class="type">Int</span></span><br><span class="line">    &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>, <span class="type">Generic</span>)</span></span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">ToJSON</span> <span class="type">Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">FromJSON</span> <span class="type">Person</span></span></span><br></pre></td></tr></table></figure>
<p>Here we’ve defined a new record type <code>Person</code> with 2 fields. You can imagine how this would look in JSON:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"David"</span></span><br><span class="line">, <span class="attr">"age"</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>instance ToJSON Person</code> automatically creates an instance that will allow the <code>encode</code> function to generate exactly the JSON above. In a similar way, <code>instance FromJSON Person</code> will allow us to <code>decode</code> the above JSON into a Person record. That’s 2 lines of code!</p>
<p>Sometimes we might want to modify the JSON produced slightly, for example in order to generate lenses with TemplateHaskell you add an <code>_</code> in front of the field names:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DeriveGeneric   #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TemplateHaskell #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> Lib <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>           Control.Lens</span><br><span class="line"><span class="keyword">import</span>           Data.Aeson</span><br><span class="line"><span class="keyword">import</span>           Data.Aeson.Types</span><br><span class="line"><span class="keyword">import</span>           Data.Text        (<span class="type">Text</span>)</span><br><span class="line"><span class="keyword">import</span>           GHC.Generics</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span></span></span><br><span class="line">  &#123; _name :: <span class="type">Text</span></span><br><span class="line">  , _age  :: <span class="type">Int</span></span><br><span class="line">  &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>, <span class="type">Generic</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">makeLenses</span> ''<span class="type">Person</span></span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">ToJSON</span> <span class="type">Person</span> <span class="keyword">where</span></span></span><br><span class="line">  toJSON = genericToJSON defaultOptions &#123;fieldLabelModifier = drop <span class="number">1</span>&#125;</span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">FromJSON</span> <span class="type">Person</span> <span class="keyword">where</span></span></span><br><span class="line">  parseJSON = genericParseJSON defaultOptions &#123;fieldLabelModifier = drop <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>That’s not too bad, however now our JSON is a little less trustworthy, especially if we start doing even more customisation of the <code>ToJSON</code> and <code>FromJSON</code> instances. How do we know that the encode/decode functions work correctly?</p>
<p>This is where QuickCheck comes in. Using <a href="https://hackage.haskell.org/package/generic-arbitrary" target="_blank" rel="external">generic-arbitrary</a> we can create an <code>Arbitrary</code> instance of <code>Person</code> and use QuickCheck to test random samples of <code>Person</code> data:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Main <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>           Data.Aeson                           (<span class="type">FromJSON</span>, <span class="type">ToJSON</span>, <span class="title">decode</span>,</span><br><span class="line">                                                       <span class="title">encode</span>)</span><br><span class="line"><span class="keyword">import</span>           Data.Text.Arbitrary                  ()</span><br><span class="line"><span class="keyword">import</span>           Lib</span><br><span class="line"><span class="keyword">import</span>           Test.Framework                       (<span class="type">Test</span>, <span class="title">defaultMain</span>)</span><br><span class="line"><span class="keyword">import</span>           Test.Framework.Providers.QuickCheck2 (<span class="title">testProperty</span>)</span><br><span class="line"><span class="keyword">import</span>           Test.QuickCheck.Arbitrary.Generic    (<span class="type">Arbitrary</span>, <span class="title">arbitrary</span>,</span><br><span class="line">                                                       <span class="title">genericArbitrary</span>,</span><br><span class="line">                                                       <span class="title">genericShrink</span>, <span class="title">shrink</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">personTest</span> :: <span class="type">Test</span></span><br><span class="line"><span class="title">personTest</span> = testProperty <span class="string">"Encode and decode a Person"</span> (jsonProperties :: <span class="type">Person</span> -&gt; <span class="type">Bool</span>)</span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">Arbitrary</span> <span class="type">Person</span> <span class="keyword">where</span></span></span><br><span class="line">  arbitrary = genericArbitrary</span><br><span class="line">  shrink = genericShrink</span><br><span class="line"></span><br><span class="line"><span class="title">jsonProperties</span> :: (<span class="type">Eq</span> a, <span class="type">ToJSON</span> a, <span class="type">FromJSON</span> a) =&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">jsonProperties</span> a = <span class="type">Just</span> a == (decode . encode) a</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = defaultMain [personTest]</span><br></pre></td></tr></table></figure>
<p>Now we can be pretty confident about the correctness of our JSON conversions.</p>
<p>Until I started using Haskell professionally, I wasn’t totally sold on static typing, however it’s examples like these that have converted me. With as little as 7 lines of code we can be sure that the data we are sending over the wire adheres to our API contract at compile time.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/05/14/the-repl-as-a-business-tool/" class="next">PREVIOUS</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://shmish111.github.io">David Smith</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-52255315-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>