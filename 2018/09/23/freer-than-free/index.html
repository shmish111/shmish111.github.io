<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Freer than Free · Continuously Improving</title><meta name="description" content="Freer than Free - David Smith"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/shmish111" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Freer than Free</h1><div class="post-time">Sep 23, 2018</div><div class="post-content"><blockquote>
<p>freer-simple is a fantastic library and I will definitely use it again. I found some gaps in the documentation that I aim to address here.</p>
</blockquote>
<p>Recently I needed to glue some terraform, nixops and ssh commands together so as soon as I realised that bash was quickly going to become unweildly I set about writing a small Haskell program. I had recently worked on a cli app that used a Free monad and found there was quite a lot of boiler plate for little benefit so I decided to use this app to find out about the current state of Freer monads in Haskell.<br><a id="more"></a></p>
<h2 id="Eff-and-the-Freer-Monad"><a href="#Eff-and-the-Freer-Monad" class="headerlink" title="Eff and the Freer Monad"></a>Eff and the Freer Monad</h2><p>The <a href="http://hackage.haskell.org/package/freer-simple" target="_blank" rel="external">Hackage documentation of freer-simple</a> provides some sample code and links to the papers that laid out the groundwork for this library so I’m not going to attempt to explain what the <code>Freer</code> monad is, rather I’m going to explain why its useful and give an example of how you can use it.</p>
<p>With the Freer monad, all monadic code resides within one Monad called <code>Eff</code>. Rather than the ‘stack’ of monads that monad transformers provide, you place a list of constraints on <code>Eff</code> which represents the capabilities it has. You then define handlers (or interpreters) for each of these capabilities and run <code>Eff</code> through those interpreters. Finally you <code>run</code> the monad, as you do with any other monad type. Lets look at some examples:</p>
<p><strong>Console.hs</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE LambdaCase #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Console <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad.Freer</span><br><span class="line">  ( <span class="class"><span class="keyword">type</span> (~&gt;)</span></span><br><span class="line">  , <span class="type">Eff</span></span><br><span class="line">  , <span class="type">LastMember</span></span><br><span class="line">  , <span class="type">Member</span></span><br><span class="line">  , interpret</span><br><span class="line">  , interpretM</span><br><span class="line">  , send</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Freer.Writer (<span class="type">Writer</span>, <span class="title">tell</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Text (<span class="type">Text</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text.IO <span class="keyword">as</span> Text</span><br><span class="line"></span><br><span class="line"><span class="comment">-- We start by defining our effects algebra called Console</span></span><br><span class="line"><span class="comment">-- In this case we only have 1 action, PutTextLn</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Console</span> r where</span></span><br><span class="line">  <span class="type">PutTextLn</span> :: <span class="type">Text</span> -&gt; <span class="type">Console</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- This is the only boilerplate we really need, a function that hides the way</span></span><br><span class="line"><span class="comment">-- we use effects by 'sending' a Console value</span></span><br><span class="line"><span class="title">putTextLn</span> :: <span class="type">Member</span> <span class="type">Console</span> effs =&gt; <span class="type">Text</span> -&gt; <span class="type">Eff</span> effs ()</span><br><span class="line"><span class="title">putTextLn</span> = send . <span class="type">PutTextLn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- We will define an IO interpreter that will output the Text to stdout (I'll explain `~&gt;` soon)</span></span><br><span class="line"><span class="title">interpretIO</span> ::</span><br><span class="line">     (<span class="type">LastMember</span> <span class="type">IO</span> effs, <span class="type">Member</span> <span class="type">IO</span> effs) =&gt; <span class="type">Eff</span> (<span class="type">Console</span> ': effs) ~&gt; <span class="type">Eff</span> effs</span><br><span class="line"><span class="title">interpretIO</span> =</span><br><span class="line">  interpretM</span><br><span class="line">    (\<span class="keyword">case</span></span><br><span class="line">       <span class="type">PutTextLn</span> msg -&gt; <span class="type">Text</span>.putStrLn msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- We will define an alternative interpreter that adds the Text to a Writer</span></span><br><span class="line"><span class="title">interpretPure</span> :: <span class="type">Member</span> (<span class="type">Writer</span> <span class="type">Text</span>) effs =&gt; <span class="type">Eff</span> (<span class="type">Console</span> ': effs) ~&gt; <span class="type">Eff</span> effs</span><br><span class="line"><span class="title">interpretPure</span> =</span><br><span class="line">  interpret</span><br><span class="line">    (\<span class="keyword">case</span></span><br><span class="line">       <span class="type">PutTextLn</span> msg -&gt; tell msg)</span><br></pre></td></tr></table></figure>
<p><strong>Main.hs</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MonoLocalBinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> Main <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Console (<span class="type">Console</span>, <span class="title">putTextLn</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Console</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Freer (<span class="type">Member</span>, <span class="type">Eff</span>, <span class="title">run</span>, <span class="title">runM</span>)</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Freer.Writer (<span class="title">runWriter</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Text (<span class="type">Text</span>, <span class="title">unpack</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- In our example program we just want to put some Text in the console</span></span><br><span class="line"><span class="title">myProgram</span> :: <span class="type">Member</span> <span class="type">Console</span> effs =&gt; <span class="type">Text</span> -&gt; <span class="type">Eff</span> effs ()</span><br><span class="line"><span class="title">myProgram</span> = putTextLn</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="comment">-- first we can run a pure version which will give us some Text back</span></span><br><span class="line">  <span class="keyword">let</span> (_, pureMsg) = run . runWriter . <span class="type">Console</span>.interpretPure $ myProgram <span class="string">"hello"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- lets print this text</span></span><br><span class="line">  putStrLn . unpack $ pureMsg</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- now we can run the IO version which will print directly to stdout</span></span><br><span class="line">  runM . <span class="type">Console</span>.interpretIO $ myProgram <span class="string">"goodbye"</span></span><br></pre></td></tr></table></figure>
<p>This first example is pretty similar to what is shown in the <a href="http://hackage.haskell.org/package/freer-simple" target="_blank" rel="external">free-simple documentation</a> however it is different in that I have explicitly defined <code>interpretIO</code> and <code>interpretPure</code>.</p>
<h2 id="Natural-Transformations"><a href="#Natural-Transformations" class="headerlink" title="Natural Transformations"></a>Natural Transformations</h2><p>My lack of understanding of the natural transformation operator <code>~&gt;</code> and type quantifiers meant it took me some time to work out how to deal with the types. The important thing about <code>~&gt;</code> is that it hides the second type parameter of <code>Eff</code>. It turns out that in some situations, if we don’t use <code>~&gt;</code> we need to explicitly quantify this <code>(LastMember IO effs, Member IO effs) =&gt; Text -&gt; forall a. Eff (File &#39;: effs) a -&gt; Eff effs a</code> (this also requires enabling the <code>RankNTypes</code> extension). See <a href="http://hackage.haskell.org/package/natural-transformation-0.4/docs/Control-Natural.html#t:-126--62-" target="_blank" rel="external">here</a></p>
<p>The simplest thing to do is just to use <code>~&gt;</code> in your interpreter’s type signatures. I had a basic understanding of natural transformations however I had never managed to quite equate them to programming. I found that using <code>Eff</code> and writing interpreters help me gain an intuition for what is going on.</p>
<h2 id="Composing-Effects"><a href="#Composing-Effects" class="headerlink" title="Composing Effects"></a>Composing Effects</h2><p>Now that we know how to properly define effect algebras and interpreters, lets compose 2 different effects. First we’ll create a new effect, <code>File</code>:</p>
<p><strong>File.hs</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE GADTs #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE TypeOperators #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE LambdaCase #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> File <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Control.Monad.Freer</span><br><span class="line">  ( <span class="class"><span class="keyword">type</span> (~&gt;)</span></span><br><span class="line">  , <span class="type">Eff</span></span><br><span class="line">  , <span class="type">LastMember</span></span><br><span class="line">  , <span class="type">Member</span></span><br><span class="line">  , interpret</span><br><span class="line">  , interpretM</span><br><span class="line">  , send</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Freer.Writer (<span class="type">Writer</span>, <span class="title">tell</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Text (<span class="type">Text</span>, <span class="title">pack</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Text.IO <span class="keyword">as</span> Text</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">File</span> r where</span></span><br><span class="line">  <span class="type">ReadFile</span> :: <span class="type">FilePath</span> -&gt; <span class="type">File</span> <span class="type">Text</span></span><br><span class="line"></span><br><span class="line"><span class="title">readFile</span> :: <span class="type">Member</span> <span class="type">File</span> effs =&gt; <span class="type">FilePath</span> -&gt; <span class="type">Eff</span> effs <span class="type">Text</span></span><br><span class="line"><span class="title">readFile</span> = send . <span class="type">ReadFile</span></span><br><span class="line"></span><br><span class="line"><span class="title">interpretIO</span> ::</span><br><span class="line">     (<span class="type">LastMember</span> <span class="type">IO</span> effs, <span class="type">Member</span> <span class="type">IO</span> effs) =&gt; <span class="type">Eff</span> (<span class="type">File</span> ': effs) ~&gt; <span class="type">Eff</span> effs</span><br><span class="line"><span class="title">interpretIO</span> =</span><br><span class="line">  interpretM</span><br><span class="line">    (\<span class="keyword">case</span></span><br><span class="line">       <span class="type">ReadFile</span> path -&gt; <span class="type">Text</span>.readFile path)</span><br><span class="line"></span><br><span class="line"><span class="title">interpretPure</span> :: <span class="type">Member</span> (<span class="type">Writer</span> <span class="type">Text</span>) effs =&gt; <span class="type">Eff</span> (<span class="type">File</span> ': effs) ~&gt; <span class="type">Eff</span> effs</span><br><span class="line"><span class="title">interpretPure</span> =</span><br><span class="line">  interpret</span><br><span class="line">    (\<span class="keyword">case</span></span><br><span class="line">       <span class="type">ReadFile</span> path -&gt; <span class="keyword">do</span></span><br><span class="line">         tell $ <span class="string">"try to read file "</span> &lt;&gt; pack path</span><br><span class="line">         pure <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>Now lets change our program so that it reads a file and outputs its contents to the console.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE MonoLocalBinds #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE OverloadedStrings #-&#125;</span></span><br><span class="line"><span class="meta">&#123;-# LANGUAGE DataKinds #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Main <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Console (<span class="type">Console</span>, <span class="title">putTextLn</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Console</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Freer (<span class="type">Eff</span>, <span class="type">Members</span>, <span class="title">run</span>, <span class="title">runM</span>)</span><br><span class="line"><span class="keyword">import</span> Control.Monad.Freer.Writer (<span class="title">runWriter</span>)</span><br><span class="line"><span class="keyword">import</span> Data.Text (<span class="type">Text</span>, <span class="title">unpack</span>)</span><br><span class="line"><span class="keyword">import</span> File (<span class="type">File</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> File</span><br><span class="line"></span><br><span class="line"><span class="title">myProgram</span> :: <span class="type">Members</span> '[ <span class="type">Console</span>, <span class="type">File</span>] effs =&gt; <span class="type">Eff</span> effs ()</span><br><span class="line"><span class="title">myProgram</span> = <span class="keyword">do</span></span><br><span class="line">  contents &lt;- <span class="type">File</span>.readFile <span class="string">"myfile.txt"</span></span><br><span class="line">  putTextLn contents</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">let</span> (_, pureMsg) =</span><br><span class="line">        run . runWriter . <span class="type">Console</span>.interpretPure . <span class="type">File</span>.interpretPure $ myProgram</span><br><span class="line">  putStrLn . unpack $ pureMsg</span><br><span class="line">  runM . <span class="type">Console</span>.interpretIO . <span class="type">File</span>.interpretIO $ myProgram</span><br></pre></td></tr></table></figure>
<p>There are 2 big advantages here:</p>
<ol>
<li>It is easy to compose code that uses different effects, no more <code>lift</code> or defining loads of mtl-style instances. Instead we use normal function composition to compose interpreters.</li>
<li>You can easily define different interpreters. For example one thing that was really nice in my program was that it was very easy to add a <code>--dry-run</code> flag to my program, if a user adds this flag I simply use pure interpreters for effects and build up a writer monad of what the code <em>would</em> have done if you had run it without the flag.</li>
</ol>
<p>One thing to note is that interpreters don’t need to be totally pure or monadic, in my <code>--dry-run</code> case I composed IO interpreters with pure ones.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>I wanted some interaction with the console so I built a <code>Console</code> effect algebra. I can use that effect in code that runs in the <code>Eff</code> monad as long as I add a constraint to say that I’m using that effect. I end up with code that runs in an <code>Eff</code> with a (type-level) list of constraints, for example <code>[ Reader Env, Console, File]</code>. </p>
<p>I then put this code through various interpreters, each of which removes a constraint. Eventually I am left with an empty list or, if we wish to end up inside some monad, a list with one element.</p>
<ul>
<li>An empty list represents a pure computation so I can then <code>run</code> it to get rid of <code>Eff</code> and return a pure value.</li>
<li>A list with one element represents a monadic computation, in my case this final effect was <code>IO</code>. I can then <code>runM</code> this computation to give me a monadic value, in my case <code>IO a</code>.</li>
</ul>
<p>When you first use this library it can seem a bit complicated and it took me a while to get the hang of it but once you do, it’s quite simple and clean. In my opinion, a vast improvement over mtl-style code.</p>
<h2 id="What-are-the-downsides"><a href="#What-are-the-downsides" class="headerlink" title="What are the downsides?"></a>What are the downsides?</h2><ol>
<li>The big downside that would stop freer monads becoming ubiquitous is performance, in certain situations they can be up to 30x slower than a monad transformer. Although there are no fundamental limits on how much this could be improved, it would probably require compiler integration and very clever optimazation so it’s highly likely that monad transformers will be faster for the foreseeable future.</li>
<li>Although the example in the documentation seemed simple and understandable, once I started writing my own effects I found that the documentation was lacking information about how to compose different interpreters.</li>
<li>I’m still unsure about when and where I should define custom effects. Define too many and you end up with an unwieldy constraints list as well as a big final interpretation function. Define too few and you are unable to get the level of control over interpretation that you may wish.</li>
</ol>
<p>I will definitely use freer-simple again, I felt it made my code much better than it would have been without it. As for performance, in most applications it is likely that <code>Eff</code> won’t be a bottleneck and if it is you can quite easily fall back to monad transformers in specific parts of your code.</p>
<h2 id="Is-this-the-same-as-Eff-in-Purescript"><a href="#Is-this-the-same-as-Eff-in-Purescript" class="headerlink" title="Is this the same as Eff in Purescript?"></a>Is this the same as <code>Eff</code> in Purescript?</h2><p>If you’ve ever used <code>Eff</code> purescript then the <code>Eff</code> monad from freer-simple looks very similar on the surface. It uses type-level lists of constraints in place of row types but the lists are unordered so the effect is the same. It’s not quite as pretty as purescript but it’s close.</p>
<p>However the <code>Eff</code> in purescript is basically just tagged <code>IO</code>, whereas the <code>Eff</code> in freer-simple is a Freer monad, this means it defines an algebra of effects and you separately define interpreters to handle those effects.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/08/02/looking-at-quality/" class="next">PREVIOUS</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://shmish111.github.io">David Smith</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-52255315-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>